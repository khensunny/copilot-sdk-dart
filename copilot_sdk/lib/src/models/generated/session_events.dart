// GENERATED CODE - DO NOT MODIFY BY HAND
// Source: schemas/session-events.schema.json
// Generated by json_schema2dart
// ignore_for_file: public_member_api_docs, lines_longer_than_80_chars
// ignore_for_file: avoid_catches_without_on_clauses, unnecessary_cast
// ignore_for_file: unused_local_variable, unnecessary_non_null_assertion
// ignore_for_file: prefer_interpolation_to_compose_strings, cascade_invocations

import 'dart:convert';

sealed class SessionEvent {
  const SessionEvent();

  factory SessionEvent.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches = <SessionEvent Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['type'] == 'session.start') {
      constMatches.add(SessionStart.fromJson);
      constMatchNames.add('SessionStart');
    }
    if (json['type'] == 'session.resume') {
      constMatches.add(SessionResume.fromJson);
      constMatchNames.add('SessionResume');
    }
    if (json['type'] == 'session.error') {
      constMatches.add(SessionError.fromJson);
      constMatchNames.add('SessionError');
    }
    if (json['ephemeral'] == true && json['type'] == 'session.idle') {
      constMatches.add(SessionIdle.fromJson);
      constMatchNames.add('SessionIdle');
    }
    if (json['type'] == 'session.info') {
      constMatches.add(SessionInfo.fromJson);
      constMatchNames.add('SessionInfo');
    }
    if (json['type'] == 'session.model_change') {
      constMatches.add(SessionModelChange.fromJson);
      constMatchNames.add('SessionModelChange');
    }
    if (json['type'] == 'session.import_legacy') {
      constMatches.add(SessionImportLegacy.fromJson);
      constMatchNames.add('SessionImportLegacy');
    }
    if (json['type'] == 'session.handoff') {
      constMatches.add(SessionHandoff.fromJson);
      constMatchNames.add('SessionHandoff');
    }
    if (json['type'] == 'session.truncation') {
      constMatches.add(SessionTruncation.fromJson);
      constMatchNames.add('SessionTruncation');
    }
    if (json['ephemeral'] == true &&
        json['type'] == 'session.snapshot_rewind') {
      constMatches.add(SessionSnapshotRewind.fromJson);
      constMatchNames.add('SessionSnapshotRewind');
    }
    if (json['ephemeral'] == true && json['type'] == 'session.usage_info') {
      constMatches.add(SessionUsageInfo.fromJson);
      constMatchNames.add('SessionUsageInfo');
    }
    if (json['type'] == 'session.compaction_start') {
      constMatches.add(SessionCompactionStart.fromJson);
      constMatchNames.add('SessionCompactionStart');
    }
    if (json['type'] == 'session.compaction_complete') {
      constMatches.add(SessionCompactionComplete.fromJson);
      constMatchNames.add('SessionCompactionComplete');
    }
    if (json['type'] == 'user.message') {
      constMatches.add(UserMessage.fromJson);
      constMatchNames.add('UserMessage');
    }
    if (json['ephemeral'] == true &&
        json['type'] == 'pending_messages.modified') {
      constMatches.add(PendingMessagesModified.fromJson);
      constMatchNames.add('PendingMessagesModified');
    }
    if (json['type'] == 'assistant.turn_start') {
      constMatches.add(AssistantTurnStart.fromJson);
      constMatchNames.add('AssistantTurnStart');
    }
    if (json['ephemeral'] == true && json['type'] == 'assistant.intent') {
      constMatches.add(AssistantIntent.fromJson);
      constMatchNames.add('AssistantIntent');
    }
    if (json['type'] == 'assistant.reasoning') {
      constMatches.add(AssistantReasoning.fromJson);
      constMatchNames.add('AssistantReasoning');
    }
    if (json['ephemeral'] == true &&
        json['type'] == 'assistant.reasoning_delta') {
      constMatches.add(AssistantReasoningDelta.fromJson);
      constMatchNames.add('AssistantReasoningDelta');
    }
    if (json['type'] == 'assistant.message') {
      constMatches.add(AssistantMessage.fromJson);
      constMatchNames.add('AssistantMessage');
    }
    if (json['ephemeral'] == true &&
        json['type'] == 'assistant.message_delta') {
      constMatches.add(AssistantMessageDelta.fromJson);
      constMatchNames.add('AssistantMessageDelta');
    }
    if (json['type'] == 'assistant.turn_end') {
      constMatches.add(AssistantTurnEnd.fromJson);
      constMatchNames.add('AssistantTurnEnd');
    }
    if (json['ephemeral'] == true && json['type'] == 'assistant.usage') {
      constMatches.add(AssistantUsage.fromJson);
      constMatchNames.add('AssistantUsage');
    }
    if (json['type'] == 'abort') {
      constMatches.add(Abort.fromJson);
      constMatchNames.add('Abort');
    }
    if (json['type'] == 'tool.user_requested') {
      constMatches.add(ToolUserRequested.fromJson);
      constMatchNames.add('ToolUserRequested');
    }
    if (json['type'] == 'tool.execution_start') {
      constMatches.add(ToolExecutionStart.fromJson);
      constMatchNames.add('ToolExecutionStart');
    }
    if (json['ephemeral'] == true &&
        json['type'] == 'tool.execution_partial_result') {
      constMatches.add(ToolExecutionPartialResult.fromJson);
      constMatchNames.add('ToolExecutionPartialResult');
    }
    if (json['ephemeral'] == true &&
        json['type'] == 'tool.execution_progress') {
      constMatches.add(ToolExecutionProgress.fromJson);
      constMatchNames.add('ToolExecutionProgress');
    }
    if (json['type'] == 'tool.execution_complete') {
      constMatches.add(ToolExecutionComplete.fromJson);
      constMatchNames.add('ToolExecutionComplete');
    }
    if (json['type'] == 'skill.invoked') {
      constMatches.add(SkillInvoked.fromJson);
      constMatchNames.add('SkillInvoked');
    }
    if (json['type'] == 'subagent.started') {
      constMatches.add(SubagentStarted.fromJson);
      constMatchNames.add('SubagentStarted');
    }
    if (json['type'] == 'subagent.completed') {
      constMatches.add(SubagentCompleted.fromJson);
      constMatchNames.add('SubagentCompleted');
    }
    if (json['type'] == 'subagent.failed') {
      constMatches.add(SubagentFailed.fromJson);
      constMatchNames.add('SubagentFailed');
    }
    if (json['type'] == 'subagent.selected') {
      constMatches.add(SubagentSelected.fromJson);
      constMatchNames.add('SubagentSelected');
    }
    if (json['type'] == 'hook.start') {
      constMatches.add(HookStart.fromJson);
      constMatchNames.add('HookStart');
    }
    if (json['type'] == 'hook.end') {
      constMatches.add(HookEnd.fromJson);
      constMatchNames.add('HookEnd');
    }
    if (json['type'] == 'system.message') {
      constMatches.add(SystemMessage.fromJson);
      constMatchNames.add('SystemMessage');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEvent variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches = <SessionEvent Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionStart.fromJson);
      requiredMatchNames.add('SessionStart');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionResume.fromJson);
      requiredMatchNames.add('SessionResume');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionError.fromJson);
      requiredMatchNames.add('SessionError');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionIdle.fromJson);
      requiredMatchNames.add('SessionIdle');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionInfo.fromJson);
      requiredMatchNames.add('SessionInfo');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionModelChange.fromJson);
      requiredMatchNames.add('SessionModelChange');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionImportLegacy.fromJson);
      requiredMatchNames.add('SessionImportLegacy');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionHandoff.fromJson);
      requiredMatchNames.add('SessionHandoff');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionTruncation.fromJson);
      requiredMatchNames.add('SessionTruncation');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionSnapshotRewind.fromJson);
      requiredMatchNames.add('SessionSnapshotRewind');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionUsageInfo.fromJson);
      requiredMatchNames.add('SessionUsageInfo');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionCompactionStart.fromJson);
      requiredMatchNames.add('SessionCompactionStart');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SessionCompactionComplete.fromJson);
      requiredMatchNames.add('SessionCompactionComplete');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(UserMessage.fromJson);
      requiredMatchNames.add('UserMessage');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(PendingMessagesModified.fromJson);
      requiredMatchNames.add('PendingMessagesModified');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(AssistantTurnStart.fromJson);
      requiredMatchNames.add('AssistantTurnStart');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(AssistantIntent.fromJson);
      requiredMatchNames.add('AssistantIntent');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(AssistantReasoning.fromJson);
      requiredMatchNames.add('AssistantReasoning');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(AssistantReasoningDelta.fromJson);
      requiredMatchNames.add('AssistantReasoningDelta');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(AssistantMessage.fromJson);
      requiredMatchNames.add('AssistantMessage');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(AssistantMessageDelta.fromJson);
      requiredMatchNames.add('AssistantMessageDelta');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(AssistantTurnEnd.fromJson);
      requiredMatchNames.add('AssistantTurnEnd');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(AssistantUsage.fromJson);
      requiredMatchNames.add('AssistantUsage');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(Abort.fromJson);
      requiredMatchNames.add('Abort');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(ToolUserRequested.fromJson);
      requiredMatchNames.add('ToolUserRequested');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(ToolExecutionStart.fromJson);
      requiredMatchNames.add('ToolExecutionStart');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(ToolExecutionPartialResult.fromJson);
      requiredMatchNames.add('ToolExecutionPartialResult');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('ephemeral') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(ToolExecutionProgress.fromJson);
      requiredMatchNames.add('ToolExecutionProgress');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(ToolExecutionComplete.fromJson);
      requiredMatchNames.add('ToolExecutionComplete');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SkillInvoked.fromJson);
      requiredMatchNames.add('SkillInvoked');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SubagentStarted.fromJson);
      requiredMatchNames.add('SubagentStarted');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SubagentCompleted.fromJson);
      requiredMatchNames.add('SubagentCompleted');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SubagentFailed.fromJson);
      requiredMatchNames.add('SubagentFailed');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SubagentSelected.fromJson);
      requiredMatchNames.add('SubagentSelected');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(HookStart.fromJson);
      requiredMatchNames.add('HookStart');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(HookEnd.fromJson);
      requiredMatchNames.add('HookEnd');
    }
    if (keys.contains('id') &&
        keys.contains('timestamp') &&
        keys.contains('parentId') &&
        keys.contains('type') &&
        keys.contains('data')) {
      requiredMatches.add(SystemMessage.fromJson);
      requiredMatchNames.add('SystemMessage');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEvent variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No SessionEvent variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

class Info extends SessionEventDataLegacySessionTimeline {
  const Info({
    required this.text,
    required this.type,
  }) : super();

  factory Info.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Info(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: info
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'info') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'info' but found " + actualp1 + '.',
      );
    }
  }
}

class SessionStart extends SessionEvent {
  const SessionStart({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionStart.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionStartData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionStart(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionStartData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.start
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/0/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.start') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.start' but found " + actualp5 + '.',
      );
    }
  }
}

class SessionResumeDataContext {
  const SessionResumeDataContext({
    required this.cwd,
    this.branch,
    this.gitRoot,
    this.repository,
  });

  factory SessionResumeDataContext.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final branch = json['branch'] as String?;
    remaining.remove('branch');
    final cwd = json['cwd'] as String;
    remaining.remove('cwd');
    final gitRoot = json['gitRoot'] as String?;
    remaining.remove('gitRoot');
    final repository = json['repository'] as String?;
    remaining.remove('repository');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionResumeDataContext(
      branch: branch,
      cwd: cwd,
      gitRoot: gitRoot,
      repository: repository,
    );
  }
  final String? branch;
  final String cwd;
  final String? gitRoot;
  final String? repository;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (branch != null) map['branch'] = branch;
    map['cwd'] = cwd;
    if (gitRoot != null) map['gitRoot'] = gitRoot;
    if (repository != null) map['repository'] = repository;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionResumeData {
  const SessionResumeData({
    required this.eventCount,
    required this.resumeTime,
    this.context,
  });

  factory SessionResumeData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final context = json['context'] == null
        ? null
        : SessionResumeDataContext.fromJson(
            (json['context'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('context');
    final eventCount = json['eventCount'] as double;
    remaining.remove('eventCount');
    final resumeTime = json['resumeTime'] as String;
    remaining.remove('resumeTime');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionResumeData(
      context: context,
      eventCount: eventCount,
      resumeTime: resumeTime,
    );
  }
  final SessionResumeDataContext? context;
  final double eventCount;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String resumeTime;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (context != null) map['context'] = context!.toJson();
    map['eventCount'] = eventCount;
    map['resumeTime'] = resumeTime;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionResume extends SessionEvent {
  const SessionResume({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionResume.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionResumeData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionResume(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionResumeData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.resume
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/1/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.resume') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.resume' but found " + actualp5 + '.',
      );
    }
  }
}

class SessionErrorData {
  const SessionErrorData({
    required this.errorType,
    required this.message,
    this.stack,
    this.statusCode,
  });

  factory SessionErrorData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final errorType = json['errorType'] as String;
    remaining.remove('errorType');
    final message = json['message'] as String;
    remaining.remove('message');
    final stack = json['stack'] as String?;
    remaining.remove('stack');
    final statusCode = json['statusCode'] as int?;
    remaining.remove('statusCode');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionErrorData(
      errorType: errorType,
      message: message,
      stack: stack,
      statusCode: statusCode,
    );
  }
  final String errorType;
  final String message;
  final String? stack;
  final int? statusCode;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['errorType'] = errorType;
    map['message'] = message;
    if (stack != null) map['stack'] = stack;
    if (statusCode != null) map['statusCode'] = statusCode;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionError extends SessionEvent {
  const SessionError({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionError.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionErrorData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionError(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionErrorData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.error
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/2/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.error') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.error' but found " + actualp5 + '.',
      );
    }
  }
}

class SessionIdleData {
  const SessionIdleData();

  factory SessionIdleData.fromJson(Map<String, dynamic> _) {
    return const SessionIdleData();
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionIdle extends SessionEvent {
  const SessionIdle({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory SessionIdle.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionIdleData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionIdle(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionIdleData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.idle
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/3/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.idle') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.idle' but found " + actualp5 + '.',
      );
    }
  }
}

class SessionInfoData {
  const SessionInfoData({
    required this.infoType,
    required this.message,
  });

  factory SessionInfoData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final infoType = json['infoType'] as String;
    remaining.remove('infoType');
    final message = json['message'] as String;
    remaining.remove('message');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionInfoData(
      infoType: infoType,
      message: message,
    );
  }
  final String infoType;
  final String message;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['infoType'] = infoType;
    map['message'] = message;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionInfo extends SessionEvent {
  const SessionInfo({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionInfo.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionInfoData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionInfo(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionInfoData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.info
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/4/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.info') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.info' but found " + actualp5 + '.',
      );
    }
  }
}

class SessionModelChangeData {
  const SessionModelChangeData({
    required this.newModel,
    this.previousModel,
  });

  factory SessionModelChangeData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final newModel = json['newModel'] as String;
    remaining.remove('newModel');
    final previousModel = json['previousModel'] as String?;
    remaining.remove('previousModel');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionModelChangeData(
      newModel: newModel,
      previousModel: previousModel,
    );
  }
  final String newModel;
  final String? previousModel;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['newModel'] = newModel;
    if (previousModel != null) map['previousModel'] = previousModel;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionModelChange extends SessionEvent {
  const SessionModelChange({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionModelChange.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionModelChangeData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionModelChange(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionModelChangeData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.model_change
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/5/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.model_change') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.model_change' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class DeveloperContentArrayItem {
  const DeveloperContentArrayItem({
    required this.text,
    required this.type,
  });

  factory DeveloperContentArrayItem.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return DeveloperContentArrayItem(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: text
  final String type;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'text') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'text' but found " + actualp1 + '.',
      );
    }
  }
}

sealed class DeveloperContent {
  const DeveloperContent();

  factory DeveloperContent.fromJson(dynamic json) {
    if (json is String) return DeveloperContentString(json);
    if (json is List) {
      return DeveloperContentArray(
        (json as List)
            .map(
              (e) => DeveloperContentArrayItem.fromJson(
                (e as Map).cast<String, dynamic>(),
              ),
            )
            .toList(),
      );
    }
    throw ArgumentError(
      'Invalid DeveloperContent value type: ${json.runtimeType}',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  dynamic toJson();
}

class DeveloperContentString extends DeveloperContent {
  const DeveloperContentString(this.value) : super();
  final String value;

  @override
  dynamic toJson() => value;

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class DeveloperContentArray extends DeveloperContent {
  const DeveloperContentArray(this.value) : super();
  final List<DeveloperContentArrayItem> value;

  @override
  dynamic toJson() => value.map((e) => e.toJson()).toList();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class Developer extends SessionImportLegacyDataLegacySessionChatMessage {
  const Developer({
    required this.content,
    required this.role,
    this.name,
  }) : super();

  factory Developer.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = DeveloperContent.fromJson(
      (json['content'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('content');
    final name = json['name'] as String?;
    remaining.remove('name');
    final role = json['role'] as String;
    remaining.remove('role');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Developer(
      content: content,
      name: name,
      role: role,
    );
  }
  final DeveloperContent content;
  final String? name;

  /// Constraints: const: developer
  final String role;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content.toJson();
    if (name != null) map['name'] = name;
    map['role'] = role;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'content');
    final value0 = content;
    context?.markProperty(pointer, 'content');
    final jsonp0 = value0.toJson();
    final constraintp0c0_0 = context == null ? null : ValidationContext();
    var constraintp0m0_0 = false;
    try {
      final context = constraintp0c0_0;
      final constraintp0v0_0 = jsonp0 as String;
      constraintp0m0_0 = true;
    } catch (_) {}
    final constraintp0c0_1 = context == null ? null : ValidationContext();
    var constraintp0m0_1 = false;
    try {
      final context = constraintp0c0_1;
      final constraintp0v0_1 = (jsonp0 as List)
          .map(
            (e) => DeveloperContentArrayItem.fromJson(
              (e as Map).cast<String, dynamic>(),
            ),
          )
          .toList();
      final lenp0c0b1 = constraintp0v0_1.length;
      final evaluatedp0c0b1 = List<bool>.filled(lenp0c0b1, false);
      for (var i = 0; i < lenp0c0b1; i++) {
        final itemPointer = appendJsonPointer(ptr0, i.toString());
        final item = constraintp0v0_1[i];
        item.validate(pointer: itemPointer, context: context);
        evaluatedp0c0b1[i] = true;
        context?.markItem(ptr0, i);
      }
      constraintp0m0_1 = true;
    } catch (_) {}
    final constraintp0matches0 = <bool>[constraintp0m0_0, constraintp0m0_1];
    if (!constraintp0matches0.any((value) => value)) {
      throwValidationError(
        ptr0,
        'anyOf',
        'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/0/properties/content/anyOf to validate.',
      );
    }
    if (context != null && constraintp0m0_0 && constraintp0c0_0 != null) {
      context.mergeFrom(constraintp0c0_0!);
    }
    if (context != null && constraintp0m0_1 && constraintp0c0_1 != null) {
      context.mergeFrom(constraintp0c0_1!);
    }
    final ptr1 = appendJsonPointer(pointer, 'name');
    final value1 = name;
    if (value1 != null) {
      context?.markProperty(pointer, 'name');
    }
    final ptr2 = appendJsonPointer(pointer, 'role');
    final value2 = role;
    context?.markProperty(pointer, 'role');
    final actualp2 = value2;
    if (actualp2 != 'developer') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'developer' but found " + actualp2 + '.',
      );
    }
  }
}

class SystemContentArrayItem {
  const SystemContentArrayItem({
    required this.text,
    required this.type,
  });

  factory SystemContentArrayItem.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SystemContentArrayItem(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: text
  final String type;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'text') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'text' but found " + actualp1 + '.',
      );
    }
  }
}

sealed class SystemContent {
  const SystemContent();

  factory SystemContent.fromJson(dynamic json) {
    if (json is String) return SystemContentString(json);
    if (json is List) {
      return SystemContentArray(
        (json as List)
            .map(
              (e) => SystemContentArrayItem.fromJson(
                (e as Map).cast<String, dynamic>(),
              ),
            )
            .toList(),
      );
    }
    throw ArgumentError(
      'Invalid SystemContent value type: ${json.runtimeType}',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  dynamic toJson();
}

class SystemContentString extends SystemContent {
  const SystemContentString(this.value) : super();
  final String value;

  @override
  dynamic toJson() => value;

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class SystemContentArray extends SystemContent {
  const SystemContentArray(this.value) : super();
  final List<SystemContentArrayItem> value;

  @override
  dynamic toJson() => value.map((e) => e.toJson()).toList();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class System extends SessionImportLegacyDataLegacySessionChatMessage {
  const System({
    required this.content,
    required this.role,
    this.name,
  }) : super();

  factory System.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = SystemContent.fromJson(
      (json['content'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('content');
    final name = json['name'] as String?;
    remaining.remove('name');
    final role = json['role'] as String;
    remaining.remove('role');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return System(
      content: content,
      name: name,
      role: role,
    );
  }
  final SystemContent content;
  final String? name;

  /// Constraints: const: system
  final String role;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content.toJson();
    if (name != null) map['name'] = name;
    map['role'] = role;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'content');
    final value0 = content;
    context?.markProperty(pointer, 'content');
    final jsonp0 = value0.toJson();
    final constraintp0c0_0 = context == null ? null : ValidationContext();
    var constraintp0m0_0 = false;
    try {
      final context = constraintp0c0_0;
      final constraintp0v0_0 = jsonp0 as String;
      constraintp0m0_0 = true;
    } catch (_) {}
    final constraintp0c0_1 = context == null ? null : ValidationContext();
    var constraintp0m0_1 = false;
    try {
      final context = constraintp0c0_1;
      final constraintp0v0_1 = (jsonp0 as List)
          .map(
            (e) => SystemContentArrayItem.fromJson(
              (e as Map).cast<String, dynamic>(),
            ),
          )
          .toList();
      final lenp0c0b1 = constraintp0v0_1.length;
      final evaluatedp0c0b1 = List<bool>.filled(lenp0c0b1, false);
      for (var i = 0; i < lenp0c0b1; i++) {
        final itemPointer = appendJsonPointer(ptr0, i.toString());
        final item = constraintp0v0_1[i];
        item.validate(pointer: itemPointer, context: context);
        evaluatedp0c0b1[i] = true;
        context?.markItem(ptr0, i);
      }
      constraintp0m0_1 = true;
    } catch (_) {}
    final constraintp0matches0 = <bool>[constraintp0m0_0, constraintp0m0_1];
    if (!constraintp0matches0.any((value) => value)) {
      throwValidationError(
        ptr0,
        'anyOf',
        'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/1/properties/content/anyOf to validate.',
      );
    }
    if (context != null && constraintp0m0_0 && constraintp0c0_0 != null) {
      context.mergeFrom(constraintp0c0_0!);
    }
    if (context != null && constraintp0m0_1 && constraintp0c0_1 != null) {
      context.mergeFrom(constraintp0c0_1!);
    }
    final ptr1 = appendJsonPointer(pointer, 'name');
    final value1 = name;
    if (value1 != null) {
      context?.markProperty(pointer, 'name');
    }
    final ptr2 = appendJsonPointer(pointer, 'role');
    final value2 = role;
    context?.markProperty(pointer, 'role');
    final actualp2 = value2;
    if (actualp2 != 'system') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'system' but found " + actualp2 + '.',
      );
    }
  }
}

class Text extends UserContentArrayItem {
  const Text({
    required this.text,
    required this.type,
  }) : super();

  factory Text.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Text(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: text
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'text') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'text' but found " + actualp1 + '.',
      );
    }
  }
}

class ImageUrlImageUrl {
  const ImageUrlImageUrl({
    required this.url,
    this.detail,
  });

  factory ImageUrlImageUrl.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final detail = json['detail'] == null
        ? null
        : ImageUrlImageUrlDetailJson.fromJson(json['detail'] as String);
    remaining.remove('detail');
    final url = json['url'] as String;
    remaining.remove('url');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ImageUrlImageUrl(
      detail: detail,
      url: url,
    );
  }
  final ImageUrlImageUrlDetail? detail;
  final String url;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (detail != null) map['detail'] = detail!.toJson();
    map['url'] = url;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ImageUrl extends UserContentArrayItem {
  const ImageUrl({
    required this.imageUrl,
    required this.type,
  }) : super();

  factory ImageUrl.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final imageUrl = ImageUrlImageUrl.fromJson(
      (json['image_url'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('image_url');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ImageUrl(
      imageUrl: imageUrl,
      type: type,
    );
  }
  final ImageUrlImageUrl imageUrl;

  /// Constraints: const: image_url
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['image_url'] = imageUrl.toJson();
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'image_url');
    final value0 = imageUrl;
    context?.markProperty(pointer, 'image_url');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'image_url') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'image_url' but found " + actualp1 + '.',
      );
    }
  }
}

class InputAudioInputAudio {
  const InputAudioInputAudio({
    required this.data,
    required this.format,
  });

  factory InputAudioInputAudio.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = json['data'] as String;
    remaining.remove('data');
    final format = InputAudioInputAudioFormatJson.fromJson(
      json['format'] as String,
    );
    remaining.remove('format');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return InputAudioInputAudio(
      data: data,
      format: format,
    );
  }
  final String data;
  final InputAudioInputAudioFormat format;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data;
    map['format'] = format.toJson();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class InputAudio extends UserContentArrayItem {
  const InputAudio({
    required this.inputAudio,
    required this.type,
  }) : super();

  factory InputAudio.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final inputAudio = InputAudioInputAudio.fromJson(
      (json['input_audio'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('input_audio');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return InputAudio(
      inputAudio: inputAudio,
      type: type,
    );
  }
  final InputAudioInputAudio inputAudio;

  /// Constraints: const: input_audio
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['input_audio'] = inputAudio.toJson();
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'input_audio');
    final value0 = inputAudio;
    context?.markProperty(pointer, 'input_audio');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'input_audio') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'input_audio' but found " + actualp1 + '.',
      );
    }
  }
}

class FileFile {
  const FileFile({
    this.fileDate,
    this.fileId,
    this.filename,
  });

  factory FileFile.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final fileDate = json['file_date'] as String?;
    remaining.remove('file_date');
    final fileId = json['file_id'] as String?;
    remaining.remove('file_id');
    final filename = json['filename'] as String?;
    remaining.remove('filename');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return FileFile(
      fileDate: fileDate,
      fileId: fileId,
      filename: filename,
    );
  }
  final String? fileDate;
  final String? fileId;
  final String? filename;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (fileDate != null) map['file_date'] = fileDate;
    if (fileId != null) map['file_id'] = fileId;
    if (filename != null) map['filename'] = filename;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class File extends UserContentArrayItem {
  const File({
    required this.file,
    required this.type,
  }) : super();

  factory File.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final file = FileFile.fromJson(
      (json['file'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('file');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return File(
      file: file,
      type: type,
    );
  }
  final FileFile file;

  /// Constraints: const: file
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['file'] = file.toJson();
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'file');
    final value0 = file;
    context?.markProperty(pointer, 'file');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'file') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'file' but found " + actualp1 + '.',
      );
    }
  }
}

sealed class UserContentArrayItem {
  const UserContentArrayItem();

  factory UserContentArrayItem.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches =
        <UserContentArrayItem Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['type'] == 'text') {
      constMatches.add(Text.fromJson);
      constMatchNames.add('Text');
    }
    if (json['type'] == 'image_url') {
      constMatches.add(ImageUrl.fromJson);
      constMatchNames.add('ImageUrl');
    }
    if (json['type'] == 'input_audio') {
      constMatches.add(InputAudio.fromJson);
      constMatchNames.add('InputAudio');
    }
    if (json['type'] == 'file') {
      constMatches.add(File.fromJson);
      constMatchNames.add('File');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous UserContentArrayItem variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <UserContentArrayItem Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('type') && keys.contains('text')) {
      requiredMatches.add(Text.fromJson);
      requiredMatchNames.add('Text');
    }
    if (keys.contains('type') && keys.contains('image_url')) {
      requiredMatches.add(ImageUrl.fromJson);
      requiredMatchNames.add('ImageUrl');
    }
    if (keys.contains('type') && keys.contains('input_audio')) {
      requiredMatches.add(InputAudio.fromJson);
      requiredMatchNames.add('InputAudio');
    }
    if (keys.contains('type') && keys.contains('file')) {
      requiredMatches.add(File.fromJson);
      requiredMatchNames.add('File');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous UserContentArrayItem variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No UserContentArrayItem variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

sealed class UserContent {
  const UserContent();

  factory UserContent.fromJson(dynamic json) {
    if (json is String) return UserContentString(json);
    if (json is List) {
      return UserContentArray(
        (json as List)
            .map(
              (e) => UserContentArrayItem.fromJson(
                (e as Map).cast<String, dynamic>(),
              ),
            )
            .toList(),
      );
    }
    throw ArgumentError('Invalid UserContent value type: ${json.runtimeType}');
  }

  void validate({String pointer = '', ValidationContext? context});

  dynamic toJson();
}

class UserContentString extends UserContent {
  const UserContentString(this.value) : super();
  final String value;

  @override
  dynamic toJson() => value;

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class UserContentArray extends UserContent {
  const UserContentArray(this.value) : super();
  final List<UserContentArrayItem> value;

  @override
  dynamic toJson() => value.map((e) => e.toJson()).toList();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class User extends SessionImportLegacyDataLegacySessionChatMessage {
  const User({
    required this.content,
    required this.role,
    this.name,
  }) : super();

  factory User.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = UserContent.fromJson(
      (json['content'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('content');
    final name = json['name'] as String?;
    remaining.remove('name');
    final role = json['role'] as String;
    remaining.remove('role');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return User(
      content: content,
      name: name,
      role: role,
    );
  }
  final UserContent content;
  final String? name;

  /// Constraints: const: user
  final String role;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content.toJson();
    if (name != null) map['name'] = name;
    map['role'] = role;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'content');
    final value0 = content;
    context?.markProperty(pointer, 'content');
    final jsonp0 = value0.toJson();
    final constraintp0c0_0 = context == null ? null : ValidationContext();
    var constraintp0m0_0 = false;
    try {
      final context = constraintp0c0_0;
      final constraintp0v0_0 = jsonp0 as String;
      constraintp0m0_0 = true;
    } catch (_) {}
    final constraintp0c0_1 = context == null ? null : ValidationContext();
    var constraintp0m0_1 = false;
    try {
      final context = constraintp0c0_1;
      final constraintp0v0_1 = (jsonp0 as List)
          .map(
            (e) => UserContentArrayItem.fromJson(
              (e as Map).cast<String, dynamic>(),
            ),
          )
          .toList();
      final lenp0c0b1 = constraintp0v0_1.length;
      final evaluatedp0c0b1 = List<bool>.filled(lenp0c0b1, false);
      for (var i = 0; i < lenp0c0b1; i++) {
        final itemPointer = appendJsonPointer(ptr0, i.toString());
        final item = constraintp0v0_1[i];
        final jsonp0c0b1i = item.toJson();
        final constraintp0c0b1ic0_0 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1im0_0 = false;
        try {
          final context = constraintp0c0b1ic0_0;
          final constraintp0c0b1iv0_0 = Text.fromJson(
            (jsonp0c0b1i as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1iv0_0.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp0c0b1im0_0 = true;
        } catch (_) {}
        final constraintp0c0b1ic0_1 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1im0_1 = false;
        try {
          final context = constraintp0c0b1ic0_1;
          final constraintp0c0b1iv0_1 = ImageUrl.fromJson(
            (jsonp0c0b1i as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1iv0_1.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp0c0b1im0_1 = true;
        } catch (_) {}
        final constraintp0c0b1ic0_2 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1im0_2 = false;
        try {
          final context = constraintp0c0b1ic0_2;
          final constraintp0c0b1iv0_2 = InputAudio.fromJson(
            (jsonp0c0b1i as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1iv0_2.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp0c0b1im0_2 = true;
        } catch (_) {}
        final constraintp0c0b1ic0_3 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1im0_3 = false;
        try {
          final context = constraintp0c0b1ic0_3;
          final constraintp0c0b1iv0_3 = File.fromJson(
            (jsonp0c0b1i as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1iv0_3.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp0c0b1im0_3 = true;
        } catch (_) {}
        final constraintp0c0b1imatches0 = <bool>[
          constraintp0c0b1im0_0,
          constraintp0c0b1im0_1,
          constraintp0c0b1im0_2,
          constraintp0c0b1im0_3,
        ];
        if (!constraintp0c0b1imatches0.any((value) => value)) {
          throwValidationError(
            itemPointer,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/2/properties/content/anyOf/1/items/anyOf to validate.',
          );
        }
        if (context != null &&
            constraintp0c0b1im0_0 &&
            constraintp0c0b1ic0_0 != null) {
          context.mergeFrom(constraintp0c0b1ic0_0!);
        }
        if (context != null &&
            constraintp0c0b1im0_1 &&
            constraintp0c0b1ic0_1 != null) {
          context.mergeFrom(constraintp0c0b1ic0_1!);
        }
        if (context != null &&
            constraintp0c0b1im0_2 &&
            constraintp0c0b1ic0_2 != null) {
          context.mergeFrom(constraintp0c0b1ic0_2!);
        }
        if (context != null &&
            constraintp0c0b1im0_3 &&
            constraintp0c0b1ic0_3 != null) {
          context.mergeFrom(constraintp0c0b1ic0_3!);
        }
        evaluatedp0c0b1[i] = true;
        context?.markItem(ptr0, i);
      }
      constraintp0m0_1 = true;
    } catch (_) {}
    final constraintp0matches0 = <bool>[constraintp0m0_0, constraintp0m0_1];
    if (!constraintp0matches0.any((value) => value)) {
      throwValidationError(
        ptr0,
        'anyOf',
        'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/2/properties/content/anyOf to validate.',
      );
    }
    if (context != null && constraintp0m0_0 && constraintp0c0_0 != null) {
      context.mergeFrom(constraintp0c0_0!);
    }
    if (context != null && constraintp0m0_1 && constraintp0c0_1 != null) {
      context.mergeFrom(constraintp0c0_1!);
    }
    final ptr1 = appendJsonPointer(pointer, 'name');
    final value1 = name;
    if (value1 != null) {
      context?.markProperty(pointer, 'name');
    }
    final ptr2 = appendJsonPointer(pointer, 'role');
    final value2 = role;
    context?.markProperty(pointer, 'role');
    final actualp2 = value2;
    if (actualp2 != 'user') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'user' but found " + actualp2 + '.',
      );
    }
  }
}

class AssistantAudioObject {
  const AssistantAudioObject({
    required this.id,
  });

  factory AssistantAudioObject.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final id = json['id'] as String;
    remaining.remove('id');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantAudioObject(
      id: id,
    );
  }
  final String id;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['id'] = id;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class Text2 extends SessionEventDataLegacySessionChatMessageContentArrayItem {
  const Text2({
    required this.text,
    required this.type,
  }) : super();

  factory Text2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Text2(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: text
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'text') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'text' but found " + actualp1 + '.',
      );
    }
  }
}

class Refusal extends SessionEventDataLegacySessionChatMessageContentArrayItem {
  const Refusal({
    required this.refusal,
    required this.type,
  }) : super();

  factory Refusal.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final refusal = json['refusal'] as String;
    remaining.remove('refusal');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Refusal(
      refusal: refusal,
      type: type,
    );
  }
  final String refusal;

  /// Constraints: const: refusal
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['refusal'] = refusal;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'refusal');
    final value0 = refusal;
    context?.markProperty(pointer, 'refusal');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'refusal') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'refusal' but found " + actualp1 + '.',
      );
    }
  }
}

sealed class SessionEventDataLegacySessionChatMessageContentArrayItem {
  const SessionEventDataLegacySessionChatMessageContentArrayItem();

  factory SessionEventDataLegacySessionChatMessageContentArrayItem.fromJson(
    Map<String, dynamic> json,
  ) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches =
        <
          SessionEventDataLegacySessionChatMessageContentArrayItem Function(
            Map<String, dynamic>,
          )
        >[];
    final constMatchNames = <String>[];
    if (json['type'] == 'text') {
      constMatches.add(Text2.fromJson);
      constMatchNames.add('Text2');
    }
    if (json['type'] == 'refusal') {
      constMatches.add(Refusal.fromJson);
      constMatchNames.add('Refusal');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionChatMessageContentArrayItem variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <
          SessionEventDataLegacySessionChatMessageContentArrayItem Function(
            Map<String, dynamic>,
          )
        >[];
    final requiredMatchNames = <String>[];
    if (keys.contains('type') && keys.contains('text')) {
      requiredMatches.add(Text2.fromJson);
      requiredMatchNames.add('Text2');
    }
    if (keys.contains('type') && keys.contains('refusal')) {
      requiredMatches.add(Refusal.fromJson);
      requiredMatchNames.add('Refusal');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionChatMessageContentArrayItem variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No SessionEventDataLegacySessionChatMessageContentArrayItem variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

sealed class SessionEventDataLegacySessionChatMessageContent {
  const SessionEventDataLegacySessionChatMessageContent();

  factory SessionEventDataLegacySessionChatMessageContent.fromJson(
    dynamic json,
  ) {
    if (json is String) {
      return SessionEventDataLegacySessionChatMessageContentString(json);
    }
    if (json is List) {
      return SessionEventDataLegacySessionChatMessageContentArray(
        (json as List)
            .map(
              (e) =>
                  SessionEventDataLegacySessionChatMessageContentArrayItem.fromJson(
                    (e as Map).cast<String, dynamic>(),
                  ),
            )
            .toList(),
      );
    }
    throw ArgumentError(
      'Invalid SessionEventDataLegacySessionChatMessageContent value type: ${json.runtimeType}',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  dynamic toJson();
}

class SessionEventDataLegacySessionChatMessageContentString
    extends SessionEventDataLegacySessionChatMessageContent {
  const SessionEventDataLegacySessionChatMessageContentString(this.value)
    : super();
  final String value;

  @override
  dynamic toJson() => value;

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionEventDataLegacySessionChatMessageContentArray
    extends SessionEventDataLegacySessionChatMessageContent {
  const SessionEventDataLegacySessionChatMessageContentArray(this.value)
    : super();
  final List<SessionEventDataLegacySessionChatMessageContentArrayItem> value;

  @override
  dynamic toJson() => value.map((e) => e.toJson()).toList();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantFunctionCallObject {
  const AssistantFunctionCallObject({
    required this.arguments,
    required this.name,
  });

  factory AssistantFunctionCallObject.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final arguments = json['arguments'] as String;
    remaining.remove('arguments');
    final name = json['name'] as String;
    remaining.remove('name');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantFunctionCallObject(
      arguments: arguments,
      name: name,
    );
  }
  final String arguments;
  final String name;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['arguments'] = arguments;
    map['name'] = name;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class FunctionFunction {
  const FunctionFunction({
    required this.arguments,
    required this.name,
  });

  factory FunctionFunction.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final arguments = json['arguments'] as String;
    remaining.remove('arguments');
    final name = json['name'] as String;
    remaining.remove('name');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return FunctionFunction(
      arguments: arguments,
      name: name,
    );
  }
  final String arguments;
  final String name;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['arguments'] = arguments;
    map['name'] = name;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class FunctionToolCall extends AssistantToolCall {
  const FunctionToolCall({
    required this.function,
    required this.id,
    required this.type,
  }) : super();

  factory FunctionToolCall.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final function = FunctionFunction.fromJson(
      (json['function'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('function');
    final id = json['id'] as String;
    remaining.remove('id');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return FunctionToolCall(
      function: function,
      id: id,
      type: type,
    );
  }
  final FunctionFunction function;
  final String id;

  /// Constraints: const: function
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['function'] = function.toJson();
    map['id'] = id;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'function');
    final value0 = function;
    context?.markProperty(pointer, 'function');
    final ptr1 = appendJsonPointer(pointer, 'id');
    final value1 = id;
    context?.markProperty(pointer, 'id');
    final ptr2 = appendJsonPointer(pointer, 'type');
    final value2 = type;
    context?.markProperty(pointer, 'type');
    final actualp2 = value2;
    if (actualp2 != 'function') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'function' but found " + actualp2 + '.',
      );
    }
  }
}

class CustomCustom {
  const CustomCustom({
    required this.input,
    required this.name,
  });

  factory CustomCustom.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final input = json['input'] as String;
    remaining.remove('input');
    final name = json['name'] as String;
    remaining.remove('name');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return CustomCustom(
      input: input,
      name: name,
    );
  }
  final String input;
  final String name;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['input'] = input;
    map['name'] = name;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class Custom extends AssistantToolCall {
  const Custom({
    required this.custom,
    required this.id,
    required this.type,
  }) : super();

  factory Custom.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final custom = CustomCustom.fromJson(
      (json['custom'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('custom');
    final id = json['id'] as String;
    remaining.remove('id');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Custom(
      custom: custom,
      id: id,
      type: type,
    );
  }
  final CustomCustom custom;
  final String id;

  /// Constraints: const: custom
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['custom'] = custom.toJson();
    map['id'] = id;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'custom');
    final value0 = custom;
    context?.markProperty(pointer, 'custom');
    final ptr1 = appendJsonPointer(pointer, 'id');
    final value1 = id;
    context?.markProperty(pointer, 'id');
    final ptr2 = appendJsonPointer(pointer, 'type');
    final value2 = type;
    context?.markProperty(pointer, 'type');
    final actualp2 = value2;
    if (actualp2 != 'custom') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'custom' but found " + actualp2 + '.',
      );
    }
  }
}

sealed class AssistantToolCall {
  const AssistantToolCall();

  factory AssistantToolCall.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches = <AssistantToolCall Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['type'] == 'function') {
      constMatches.add(FunctionToolCall.fromJson);
      constMatchNames.add('FunctionToolCall');
    }
    if (json['type'] == 'custom') {
      constMatches.add(Custom.fromJson);
      constMatchNames.add('Custom');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous AssistantToolCall variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <AssistantToolCall Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('id') &&
        keys.contains('type') &&
        keys.contains('function')) {
      requiredMatches.add(FunctionToolCall.fromJson);
      requiredMatchNames.add('FunctionToolCall');
    }
    if (keys.contains('id') &&
        keys.contains('type') &&
        keys.contains('custom')) {
      requiredMatches.add(Custom.fromJson);
      requiredMatchNames.add('Custom');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous AssistantToolCall variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No AssistantToolCall variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

class Assistant extends SessionImportLegacyDataLegacySessionChatMessage {
  const Assistant({
    required this.role,
    this.audio,
    this.content,
    this.functionCall,
    this.name,
    this.refusal,
    this.toolCalls,
  }) : super();

  factory Assistant.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final audio = json['audio'] == null
        ? null
        : AssistantAudioObject.fromJson(
            (json['audio'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('audio');
    final content = json['content'] == null
        ? null
        : SessionEventDataLegacySessionChatMessageContent.fromJson(
            (json['content'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('content');
    final functionCall = json['function_call'] == null
        ? null
        : AssistantFunctionCallObject.fromJson(
            (json['function_call'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('function_call');
    final name = json['name'] as String?;
    remaining.remove('name');
    final refusal = json['refusal'] as String?;
    remaining.remove('refusal');
    final role = json['role'] as String;
    remaining.remove('role');
    final toolCalls = json['tool_calls'] == null
        ? null
        : (json['tool_calls'] as List)
              .map(
                (e) => AssistantToolCall.fromJson(
                  (e as Map).cast<String, dynamic>(),
                ),
              )
              .toList();
    remaining.remove('tool_calls');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Assistant(
      audio: audio,
      content: content,
      functionCall: functionCall,
      name: name,
      refusal: refusal,
      role: role,
      toolCalls: toolCalls,
    );
  }
  final AssistantAudioObject? audio;
  final SessionEventDataLegacySessionChatMessageContent? content;
  final AssistantFunctionCallObject? functionCall;
  final String? name;

  /// Constraints: types: [string, null]
  final String? refusal;

  /// Constraints: const: assistant
  final String role;
  final List<AssistantToolCall>? toolCalls;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (audio != null) map['audio'] = audio!.toJson();
    if (content != null) map['content'] = content!.toJson();
    if (functionCall != null) map['function_call'] = functionCall!.toJson();
    if (name != null) map['name'] = name;
    if (refusal != null) map['refusal'] = refusal;
    map['role'] = role;
    if (toolCalls != null) {
      map['tool_calls'] = toolCalls!.map((e) => e.toJson()).toList();
    }
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'audio');
    final value0 = audio;
    if (value0 != null) {
      context?.markProperty(pointer, 'audio');
      final jsonp0 = value0.toJson();
      final constraintp0c0_0 = context == null ? null : ValidationContext();
      var constraintp0m0_0 = false;
      try {
        final context = constraintp0c0_0;
        final constraintp0v0_0 = AssistantAudioObject.fromJson(
          (jsonp0 as Map).cast<String, dynamic>(),
        );
        constraintp0m0_0 = true;
      } catch (_) {}
      final constraintp0c0_1 = context == null ? null : ValidationContext();
      var constraintp0m0_1 = false;
      try {
        final context = constraintp0c0_1;
        final constraintp0v0_1 = jsonp0;
        constraintp0m0_1 = true;
      } catch (_) {}
      final constraintp0matches0 = <bool>[constraintp0m0_0, constraintp0m0_1];
      if (!constraintp0matches0.any((value) => value)) {
        throwValidationError(
          ptr0,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/3/properties/audio/anyOf to validate.',
        );
      }
      if (context != null && constraintp0m0_0 && constraintp0c0_0 != null) {
        context.mergeFrom(constraintp0c0_0!);
      }
      if (context != null && constraintp0m0_1 && constraintp0c0_1 != null) {
        context.mergeFrom(constraintp0c0_1!);
      }
    }
    final ptr1 = appendJsonPointer(pointer, 'content');
    final value1 = content;
    if (value1 != null) {
      context?.markProperty(pointer, 'content');
      final jsonp1 = value1.toJson();
      final constraintp1c0_0 = context == null ? null : ValidationContext();
      var constraintp1m0_0 = false;
      try {
        final context = constraintp1c0_0;
        final constraintp1v0_0 =
            SessionEventDataLegacySessionChatMessageContent.fromJson(
              (jsonp1 as Map).cast<String, dynamic>(),
            );
        final jsonp1c0b0 = constraintp1v0_0.toJson();
        final constraintp1c0b0c0_0 = context == null
            ? null
            : ValidationContext();
        var constraintp1c0b0m0_0 = false;
        try {
          final context = constraintp1c0b0c0_0;
          final constraintp1c0b0v0_0 = jsonp1c0b0 as String;
          constraintp1c0b0m0_0 = true;
        } catch (_) {}
        final constraintp1c0b0c0_1 = context == null
            ? null
            : ValidationContext();
        var constraintp1c0b0m0_1 = false;
        try {
          final context = constraintp1c0b0c0_1;
          final constraintp1c0b0v0_1 = (jsonp1c0b0 as List)
              .map(
                (e) =>
                    SessionEventDataLegacySessionChatMessageContentArrayItem.fromJson(
                      (e as Map).cast<String, dynamic>(),
                    ),
              )
              .toList();
          final lenp1c0b0c0b1 = constraintp1c0b0v0_1.length;
          final evaluatedp1c0b0c0b1 = List<bool>.filled(lenp1c0b0c0b1, false);
          for (var i = 0; i < lenp1c0b0c0b1; i++) {
            final itemPointer = appendJsonPointer(ptr1, i.toString());
            final item = constraintp1c0b0v0_1[i];
            final jsonp1c0b0c0b1i = item.toJson();
            final constraintp1c0b0c0b1ic0_0 = context == null
                ? null
                : ValidationContext();
            var constraintp1c0b0c0b1im0_0 = false;
            try {
              final context = constraintp1c0b0c0b1ic0_0;
              final constraintp1c0b0c0b1iv0_0 = Text2.fromJson(
                (jsonp1c0b0c0b1i as Map).cast<String, dynamic>(),
              );
              constraintp1c0b0c0b1iv0_0.validate(
                pointer: itemPointer,
                context: context,
              );
              constraintp1c0b0c0b1im0_0 = true;
            } catch (_) {}
            final constraintp1c0b0c0b1ic0_1 = context == null
                ? null
                : ValidationContext();
            var constraintp1c0b0c0b1im0_1 = false;
            try {
              final context = constraintp1c0b0c0b1ic0_1;
              final constraintp1c0b0c0b1iv0_1 = Refusal.fromJson(
                (jsonp1c0b0c0b1i as Map).cast<String, dynamic>(),
              );
              constraintp1c0b0c0b1iv0_1.validate(
                pointer: itemPointer,
                context: context,
              );
              constraintp1c0b0c0b1im0_1 = true;
            } catch (_) {}
            final constraintp1c0b0c0b1imatches0 = <bool>[
              constraintp1c0b0c0b1im0_0,
              constraintp1c0b0c0b1im0_1,
            ];
            if (!constraintp1c0b0c0b1imatches0.any((value) => value)) {
              throwValidationError(
                itemPointer,
                'anyOf',
                'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/3/properties/content/anyOf/0/anyOf/1/items/anyOf to validate.',
              );
            }
            if (context != null &&
                constraintp1c0b0c0b1im0_0 &&
                constraintp1c0b0c0b1ic0_0 != null) {
              context.mergeFrom(constraintp1c0b0c0b1ic0_0!);
            }
            if (context != null &&
                constraintp1c0b0c0b1im0_1 &&
                constraintp1c0b0c0b1ic0_1 != null) {
              context.mergeFrom(constraintp1c0b0c0b1ic0_1!);
            }
            evaluatedp1c0b0c0b1[i] = true;
            context?.markItem(ptr1, i);
          }
          constraintp1c0b0m0_1 = true;
        } catch (_) {}
        final constraintp1c0b0matches0 = <bool>[
          constraintp1c0b0m0_0,
          constraintp1c0b0m0_1,
        ];
        if (!constraintp1c0b0matches0.any((value) => value)) {
          throwValidationError(
            ptr1,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/3/properties/content/anyOf/0/anyOf to validate.',
          );
        }
        if (context != null &&
            constraintp1c0b0m0_0 &&
            constraintp1c0b0c0_0 != null) {
          context.mergeFrom(constraintp1c0b0c0_0!);
        }
        if (context != null &&
            constraintp1c0b0m0_1 &&
            constraintp1c0b0c0_1 != null) {
          context.mergeFrom(constraintp1c0b0c0_1!);
        }
        constraintp1m0_0 = true;
      } catch (_) {}
      final constraintp1c0_1 = context == null ? null : ValidationContext();
      var constraintp1m0_1 = false;
      try {
        final context = constraintp1c0_1;
        final constraintp1v0_1 = jsonp1;
        constraintp1m0_1 = true;
      } catch (_) {}
      final constraintp1matches0 = <bool>[constraintp1m0_0, constraintp1m0_1];
      if (!constraintp1matches0.any((value) => value)) {
        throwValidationError(
          ptr1,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/3/properties/content/anyOf to validate.',
        );
      }
      if (context != null && constraintp1m0_0 && constraintp1c0_0 != null) {
        context.mergeFrom(constraintp1c0_0!);
      }
      if (context != null && constraintp1m0_1 && constraintp1c0_1 != null) {
        context.mergeFrom(constraintp1c0_1!);
      }
    }
    final ptr2 = appendJsonPointer(pointer, 'function_call');
    final value2 = functionCall;
    if (value2 != null) {
      context?.markProperty(pointer, 'function_call');
      final jsonp2 = value2.toJson();
      final constraintp2c0_0 = context == null ? null : ValidationContext();
      var constraintp2m0_0 = false;
      try {
        final context = constraintp2c0_0;
        final constraintp2v0_0 = AssistantFunctionCallObject.fromJson(
          (jsonp2 as Map).cast<String, dynamic>(),
        );
        constraintp2m0_0 = true;
      } catch (_) {}
      final constraintp2c0_1 = context == null ? null : ValidationContext();
      var constraintp2m0_1 = false;
      try {
        final context = constraintp2c0_1;
        final constraintp2v0_1 = jsonp2;
        constraintp2m0_1 = true;
      } catch (_) {}
      final constraintp2matches0 = <bool>[constraintp2m0_0, constraintp2m0_1];
      if (!constraintp2matches0.any((value) => value)) {
        throwValidationError(
          ptr2,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/3/properties/function_call/anyOf to validate.',
        );
      }
      if (context != null && constraintp2m0_0 && constraintp2c0_0 != null) {
        context.mergeFrom(constraintp2c0_0!);
      }
      if (context != null && constraintp2m0_1 && constraintp2c0_1 != null) {
        context.mergeFrom(constraintp2c0_1!);
      }
    }
    final ptr3 = appendJsonPointer(pointer, 'name');
    final value3 = name;
    if (value3 != null) {
      context?.markProperty(pointer, 'name');
    }
    final ptr4 = appendJsonPointer(pointer, 'refusal');
    final value4 = refusal;
    if (value4 != null) {
      context?.markProperty(pointer, 'refusal');
    }
    final ptr5 = appendJsonPointer(pointer, 'role');
    final value5 = role;
    context?.markProperty(pointer, 'role');
    final actualp5 = value5;
    if (actualp5 != 'assistant') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant' but found " + actualp5 + '.',
      );
    }
    final ptr6 = appendJsonPointer(pointer, 'tool_calls');
    final value6 = toolCalls;
    if (value6 != null) {
      context?.markProperty(pointer, 'tool_calls');
      final lenp6 = value6.length;
      final evaluatedp6 = List<bool>.filled(lenp6, false);
      for (var i = 0; i < lenp6; i++) {
        final itemPointer = appendJsonPointer(ptr6, i.toString());
        final item = value6[i];
        final jsonp6i = item.toJson();
        final constraintp6ic0_0 = context == null ? null : ValidationContext();
        var constraintp6im0_0 = false;
        try {
          final context = constraintp6ic0_0;
          final constraintp6iv0_0 = FunctionToolCall.fromJson(
            (jsonp6i as Map).cast<String, dynamic>(),
          );
          constraintp6iv0_0.validate(pointer: itemPointer, context: context);
          constraintp6im0_0 = true;
        } catch (_) {}
        final constraintp6ic0_1 = context == null ? null : ValidationContext();
        var constraintp6im0_1 = false;
        try {
          final context = constraintp6ic0_1;
          final constraintp6iv0_1 = Custom.fromJson(
            (jsonp6i as Map).cast<String, dynamic>(),
          );
          constraintp6iv0_1.validate(pointer: itemPointer, context: context);
          constraintp6im0_1 = true;
        } catch (_) {}
        final constraintp6imatches0 = <bool>[
          constraintp6im0_0,
          constraintp6im0_1,
        ];
        if (!constraintp6imatches0.any((value) => value)) {
          throwValidationError(
            itemPointer,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/3/properties/tool_calls/items/anyOf to validate.',
          );
        }
        if (context != null && constraintp6im0_0 && constraintp6ic0_0 != null) {
          context.mergeFrom(constraintp6ic0_0!);
        }
        if (context != null && constraintp6im0_1 && constraintp6ic0_1 != null) {
          context.mergeFrom(constraintp6ic0_1!);
        }
        evaluatedp6[i] = true;
        context?.markItem(ptr6, i);
      }
    }
  }
}

class ToolContentArrayItem {
  const ToolContentArrayItem({
    required this.text,
    required this.type,
  });

  factory ToolContentArrayItem.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolContentArrayItem(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: text
  final String type;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'text') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'text' but found " + actualp1 + '.',
      );
    }
  }
}

sealed class ToolContent {
  const ToolContent();

  factory ToolContent.fromJson(dynamic json) {
    if (json is String) return ToolContentString(json);
    if (json is List) {
      return ToolContentArray(
        (json as List)
            .map(
              (e) => ToolContentArrayItem.fromJson(
                (e as Map).cast<String, dynamic>(),
              ),
            )
            .toList(),
      );
    }
    throw ArgumentError('Invalid ToolContent value type: ${json.runtimeType}');
  }

  void validate({String pointer = '', ValidationContext? context});

  dynamic toJson();
}

class ToolContentString extends ToolContent {
  const ToolContentString(this.value) : super();
  final String value;

  @override
  dynamic toJson() => value;

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolContentArray extends ToolContent {
  const ToolContentArray(this.value) : super();
  final List<ToolContentArrayItem> value;

  @override
  dynamic toJson() => value.map((e) => e.toJson()).toList();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class Tool extends SessionImportLegacyDataLegacySessionChatMessage {
  const Tool({
    required this.content,
    required this.role,
    required this.toolCallId,
  }) : super();

  factory Tool.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = ToolContent.fromJson(
      (json['content'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('content');
    final role = json['role'] as String;
    remaining.remove('role');
    final toolCallId = json['tool_call_id'] as String;
    remaining.remove('tool_call_id');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Tool(
      content: content,
      role: role,
      toolCallId: toolCallId,
    );
  }
  final ToolContent content;

  /// Constraints: const: tool
  final String role;
  final String toolCallId;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content.toJson();
    map['role'] = role;
    map['tool_call_id'] = toolCallId;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'content');
    final value0 = content;
    context?.markProperty(pointer, 'content');
    final jsonp0 = value0.toJson();
    final constraintp0c0_0 = context == null ? null : ValidationContext();
    var constraintp0m0_0 = false;
    try {
      final context = constraintp0c0_0;
      final constraintp0v0_0 = jsonp0 as String;
      constraintp0m0_0 = true;
    } catch (_) {}
    final constraintp0c0_1 = context == null ? null : ValidationContext();
    var constraintp0m0_1 = false;
    try {
      final context = constraintp0c0_1;
      final constraintp0v0_1 = (jsonp0 as List)
          .map(
            (e) => ToolContentArrayItem.fromJson(
              (e as Map).cast<String, dynamic>(),
            ),
          )
          .toList();
      final lenp0c0b1 = constraintp0v0_1.length;
      final evaluatedp0c0b1 = List<bool>.filled(lenp0c0b1, false);
      for (var i = 0; i < lenp0c0b1; i++) {
        final itemPointer = appendJsonPointer(ptr0, i.toString());
        final item = constraintp0v0_1[i];
        item.validate(pointer: itemPointer, context: context);
        evaluatedp0c0b1[i] = true;
        context?.markItem(ptr0, i);
      }
      constraintp0m0_1 = true;
    } catch (_) {}
    final constraintp0matches0 = <bool>[constraintp0m0_0, constraintp0m0_1];
    if (!constraintp0matches0.any((value) => value)) {
      throwValidationError(
        ptr0,
        'anyOf',
        'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf/4/properties/content/anyOf to validate.',
      );
    }
    if (context != null && constraintp0m0_0 && constraintp0c0_0 != null) {
      context.mergeFrom(constraintp0c0_0!);
    }
    if (context != null && constraintp0m0_1 && constraintp0c0_1 != null) {
      context.mergeFrom(constraintp0c0_1!);
    }
    final ptr1 = appendJsonPointer(pointer, 'role');
    final value1 = role;
    context?.markProperty(pointer, 'role');
    final actualp1 = value1;
    if (actualp1 != 'tool') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'tool' but found " + actualp1 + '.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'tool_call_id');
    final value2 = toolCallId;
    context?.markProperty(pointer, 'tool_call_id');
  }
}

class Function2 extends SessionImportLegacyDataLegacySessionChatMessage {
  const Function2({
    required this.name,
    required this.role,
    this.content,
  }) : super();

  factory Function2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = json['content'] as String?;
    remaining.remove('content');
    final name = json['name'] as String;
    remaining.remove('name');
    final role = json['role'] as String;
    remaining.remove('role');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Function2(
      content: content,
      name: name,
      role: role,
    );
  }

  /// Constraints: types: [string, null]
  final String? content;
  final String name;

  /// Constraints: const: function
  final String role;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (content != null) map['content'] = content;
    map['name'] = name;
    map['role'] = role;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'content');
    final value0 = content;
    if (value0 != null) {
      context?.markProperty(pointer, 'content');
    }
    final ptr1 = appendJsonPointer(pointer, 'name');
    final value1 = name;
    context?.markProperty(pointer, 'name');
    final ptr2 = appendJsonPointer(pointer, 'role');
    final value2 = role;
    context?.markProperty(pointer, 'role');
    final actualp2 = value2;
    if (actualp2 != 'function') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'function' but found " + actualp2 + '.',
      );
    }
  }
}

sealed class SessionImportLegacyDataLegacySessionChatMessage {
  const SessionImportLegacyDataLegacySessionChatMessage();

  factory SessionImportLegacyDataLegacySessionChatMessage.fromJson(
    Map<String, dynamic> json,
  ) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches =
        <
          SessionImportLegacyDataLegacySessionChatMessage Function(
            Map<String, dynamic>,
          )
        >[];
    final constMatchNames = <String>[];
    if (json['role'] == 'developer') {
      constMatches.add(Developer.fromJson);
      constMatchNames.add('Developer');
    }
    if (json['role'] == 'system') {
      constMatches.add(System.fromJson);
      constMatchNames.add('System');
    }
    if (json['role'] == 'user') {
      constMatches.add(User.fromJson);
      constMatchNames.add('User');
    }
    if (json['role'] == 'assistant') {
      constMatches.add(Assistant.fromJson);
      constMatchNames.add('Assistant');
    }
    if (json['role'] == 'tool') {
      constMatches.add(Tool.fromJson);
      constMatchNames.add('Tool');
    }
    if (json['role'] == 'function') {
      constMatches.add(Function2.fromJson);
      constMatchNames.add('Function2');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionImportLegacyDataLegacySessionChatMessage variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <
          SessionImportLegacyDataLegacySessionChatMessage Function(
            Map<String, dynamic>,
          )
        >[];
    final requiredMatchNames = <String>[];
    if (keys.contains('content') && keys.contains('role')) {
      requiredMatches.add(Developer.fromJson);
      requiredMatchNames.add('Developer');
    }
    if (keys.contains('content') && keys.contains('role')) {
      requiredMatches.add(System.fromJson);
      requiredMatchNames.add('System');
    }
    if (keys.contains('content') && keys.contains('role')) {
      requiredMatches.add(User.fromJson);
      requiredMatchNames.add('User');
    }
    if (keys.contains('role')) {
      requiredMatches.add(Assistant.fromJson);
      requiredMatchNames.add('Assistant');
    }
    if (keys.contains('content') &&
        keys.contains('role') &&
        keys.contains('tool_call_id')) {
      requiredMatches.add(Tool.fromJson);
      requiredMatchNames.add('Tool');
    }
    if (keys.contains('content') &&
        keys.contains('role') &&
        keys.contains('name')) {
      requiredMatches.add(Function2.fromJson);
      requiredMatchNames.add('Function2');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionImportLegacyDataLegacySessionChatMessage variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No SessionImportLegacyDataLegacySessionChatMessage variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

class SessionImportLegacyDataLegacySessionTimelineItem {
  const SessionImportLegacyDataLegacySessionTimelineItem({
    required this.id,
    required this.timestamp,
  });

  factory SessionImportLegacyDataLegacySessionTimelineItem.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final id = json['id'] as String;
    remaining.remove('id');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    return SessionImportLegacyDataLegacySessionTimelineItem(
      id: id,
      timestamp: timestamp,
    );
  }
  final String id;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['timestamp'] = timestamp;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class Copilot extends SessionEventDataLegacySessionTimeline {
  const Copilot({
    required this.text,
    required this.type,
    this.isStreaming,
  }) : super();

  factory Copilot.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final isStreaming = json['isStreaming'] as bool?;
    remaining.remove('isStreaming');
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Copilot(
      isStreaming: isStreaming,
      text: text,
      type: type,
    );
  }
  final bool? isStreaming;
  final String text;

  /// Constraints: const: copilot
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (isStreaming != null) map['isStreaming'] = isStreaming;
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'isStreaming');
    final value0 = isStreaming;
    if (value0 != null) {
      context?.markProperty(pointer, 'isStreaming');
    }
    final ptr1 = appendJsonPointer(pointer, 'text');
    final value1 = text;
    context?.markProperty(pointer, 'text');
    final ptr2 = appendJsonPointer(pointer, 'type');
    final value2 = type;
    context?.markProperty(pointer, 'type');
    final actualp2 = value2;
    if (actualp2 != 'copilot') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'copilot' but found " + actualp2 + '.',
      );
    }
  }
}

class Error extends SessionEventDataLegacySessionTimeline {
  const Error({
    required this.text,
    required this.type,
  }) : super();

  factory Error.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Error(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: error
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'error') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'error' but found " + actualp1 + '.',
      );
    }
  }
}

class SessionStartDataContext {
  const SessionStartDataContext({
    required this.cwd,
    this.branch,
    this.gitRoot,
    this.repository,
  });

  factory SessionStartDataContext.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final branch = json['branch'] as String?;
    remaining.remove('branch');
    final cwd = json['cwd'] as String;
    remaining.remove('cwd');
    final gitRoot = json['gitRoot'] as String?;
    remaining.remove('gitRoot');
    final repository = json['repository'] as String?;
    remaining.remove('repository');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionStartDataContext(
      branch: branch,
      cwd: cwd,
      gitRoot: gitRoot,
      repository: repository,
    );
  }
  final String? branch;
  final String cwd;
  final String? gitRoot;
  final String? repository;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (branch != null) map['branch'] = branch;
    map['cwd'] = cwd;
    if (gitRoot != null) map['gitRoot'] = gitRoot;
    if (repository != null) map['repository'] = repository;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class Warning extends SessionEventDataLegacySessionTimeline {
  const Warning({
    required this.text,
    required this.type,
  }) : super();

  factory Warning.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Warning(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: warning
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'warning') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'warning' but found " + actualp1 + '.',
      );
    }
  }
}

class User2 extends SessionEventDataLegacySessionTimeline {
  const User2({
    required this.text,
    required this.type,
  }) : super();

  factory User2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return User2(
      text: text,
      type: type,
    );
  }
  final String text;

  /// Constraints: const: user
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'text');
    final value0 = text;
    context?.markProperty(pointer, 'text');
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'user') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'user' but found " + actualp1 + '.',
      );
    }
  }
}

class SessionEventDataLegacySessionTimelineArgumentsObject
    extends SessionEventDataLegacySessionTimelineArguments {
  const SessionEventDataLegacySessionTimelineArgumentsObject({
    required this.command,
    required this.description,
    this.async_,
    this.sessionId,
    this.timeout,
  }) : super();

  factory SessionEventDataLegacySessionTimelineArgumentsObject.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final async_ = json['async'] as bool?;
    remaining.remove('async');
    final command = json['command'] as String;
    remaining.remove('command');
    final description = json['description'] as String;
    remaining.remove('description');
    final sessionId = json['sessionId'] as String?;
    remaining.remove('sessionId');
    final timeout = json['timeout'] as double?;
    remaining.remove('timeout');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionEventDataLegacySessionTimelineArgumentsObject(
      async_: async_,
      command: command,
      description: description,
      sessionId: sessionId,
      timeout: timeout,
    );
  }
  final bool? async_;
  final String command;
  final String description;
  final String? sessionId;
  final double? timeout;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (async_ != null) map['async'] = async_;
    map['command'] = command;
    map['description'] = description;
    if (sessionId != null) map['sessionId'] = sessionId;
    if (timeout != null) map['timeout'] = timeout;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionEventDataLegacySessionTimelineArgumentsObject2
    extends SessionEventDataLegacySessionTimelineArguments {
  const SessionEventDataLegacySessionTimelineArgumentsObject2({
    required this.input,
    required this.sessionId,
    this.delay,
  }) : super();

  factory SessionEventDataLegacySessionTimelineArgumentsObject2.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final delay = json['delay'] as double?;
    remaining.remove('delay');
    final input = json['input'] as String;
    remaining.remove('input');
    final sessionId = json['sessionId'] as String;
    remaining.remove('sessionId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionEventDataLegacySessionTimelineArgumentsObject2(
      delay: delay,
      input: input,
      sessionId: sessionId,
    );
  }
  final double? delay;
  final String input;
  final String sessionId;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (delay != null) map['delay'] = delay;
    map['input'] = input;
    map['sessionId'] = sessionId;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionEventDataLegacySessionTimelineArgumentsObject3
    extends SessionEventDataLegacySessionTimelineArguments {
  const SessionEventDataLegacySessionTimelineArgumentsObject3({
    required this.delay,
    required this.sessionId,
  }) : super();

  factory SessionEventDataLegacySessionTimelineArgumentsObject3.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final delay = json['delay'] as double;
    remaining.remove('delay');
    final sessionId = json['sessionId'] as String;
    remaining.remove('sessionId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionEventDataLegacySessionTimelineArgumentsObject3(
      delay: delay,
      sessionId: sessionId,
    );
  }
  final double delay;
  final String sessionId;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['delay'] = delay;
    map['sessionId'] = sessionId;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionEventDataLegacySessionTimelineArgumentsObject4
    extends SessionEventDataLegacySessionTimelineArguments {
  const SessionEventDataLegacySessionTimelineArgumentsObject4({
    required this.sessionId,
  }) : super();

  factory SessionEventDataLegacySessionTimelineArgumentsObject4.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final sessionId = json['sessionId'] as String;
    remaining.remove('sessionId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionEventDataLegacySessionTimelineArgumentsObject4(
      sessionId: sessionId,
    );
  }
  final String sessionId;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['sessionId'] = sessionId;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

sealed class SessionEventDataLegacySessionTimelineArguments {
  const SessionEventDataLegacySessionTimelineArguments();

  factory SessionEventDataLegacySessionTimelineArguments.fromJson(
    Map<String, dynamic> json,
  ) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final requiredMatches =
        <
          SessionEventDataLegacySessionTimelineArguments Function(
            Map<String, dynamic>,
          )
        >[];
    final requiredMatchNames = <String>[];
    if (keys.contains('command') && keys.contains('description')) {
      requiredMatches.add(
        SessionEventDataLegacySessionTimelineArgumentsObject.fromJson,
      );
      requiredMatchNames.add(
        'SessionEventDataLegacySessionTimelineArgumentsObject',
      );
    }
    if (keys.contains('sessionId') && keys.contains('input')) {
      requiredMatches.add(
        SessionEventDataLegacySessionTimelineArgumentsObject2.fromJson,
      );
      requiredMatchNames.add(
        'SessionEventDataLegacySessionTimelineArgumentsObject2',
      );
    }
    if (keys.contains('sessionId') && keys.contains('delay')) {
      requiredMatches.add(
        SessionEventDataLegacySessionTimelineArgumentsObject3.fromJson,
      );
      requiredMatchNames.add(
        'SessionEventDataLegacySessionTimelineArgumentsObject3',
      );
    }
    if (keys.contains('sessionId')) {
      requiredMatches.add(
        SessionEventDataLegacySessionTimelineArgumentsObject4.fromJson,
      );
      requiredMatchNames.add(
        'SessionEventDataLegacySessionTimelineArgumentsObject4',
      );
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionTimelineArguments variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No SessionEventDataLegacySessionTimelineArguments variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

class View extends SessionEventDataLegacySessionTimelineArguments2 {
  const View({
    required this.command,
    required this.path,
    this.viewRange,
  }) : super();

  factory View.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final command = json['command'] as String;
    remaining.remove('command');
    final path = json['path'] as String;
    remaining.remove('path');
    final viewRange = json['view_range'] == null
        ? null
        : (json['view_range'] as List).map((e) => e).toList();
    remaining.remove('view_range');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return View(
      command: command,
      path: path,
      viewRange: viewRange,
    );
  }

  /// Constraints: const: view
  final String command;
  final String path;

  /// Constraints: minItems: 2, maxItems: 2
  final List<dynamic>? viewRange;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['command'] = command;
    map['path'] = path;
    if (viewRange != null) map['view_range'] = viewRange;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'command');
    final value0 = command;
    context?.markProperty(pointer, 'command');
    final actualp0 = value0;
    if (actualp0 != 'view') {
      throwValidationError(
        ptr0,
        'const',
        "Expected value equal to 'view' but found " + actualp0 + '.',
      );
    }
    final ptr1 = appendJsonPointer(pointer, 'path');
    final value1 = path;
    context?.markProperty(pointer, 'path');
    final ptr2 = appendJsonPointer(pointer, 'view_range');
    final value2 = viewRange;
    if (value2 != null) {
      context?.markProperty(pointer, 'view_range');
      if (value2.length < 2) {
        throwValidationError(
          ptr2,
          'minItems',
          'Expected at least 2 items but found ${value2.length}.',
        );
      }
      if (value2.length > 2) {
        throwValidationError(
          ptr2,
          'maxItems',
          'Expected at most 2 items but found ${value2.length}.',
        );
      }
    }
  }
}

class Create extends SessionEventDataLegacySessionTimelineArguments2 {
  const Create({
    required this.command,
    required this.fileText,
    required this.path,
  }) : super();

  factory Create.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final command = json['command'] as String;
    remaining.remove('command');
    final fileText = json['file_text'] as String;
    remaining.remove('file_text');
    final path = json['path'] as String;
    remaining.remove('path');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Create(
      command: command,
      fileText: fileText,
      path: path,
    );
  }

  /// Constraints: const: create
  final String command;
  final String fileText;
  final String path;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['command'] = command;
    map['file_text'] = fileText;
    map['path'] = path;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'command');
    final value0 = command;
    context?.markProperty(pointer, 'command');
    final actualp0 = value0;
    if (actualp0 != 'create') {
      throwValidationError(
        ptr0,
        'const',
        "Expected value equal to 'create' but found " + actualp0 + '.',
      );
    }
    final ptr1 = appendJsonPointer(pointer, 'file_text');
    final value1 = fileText;
    context?.markProperty(pointer, 'file_text');
    final ptr2 = appendJsonPointer(pointer, 'path');
    final value2 = path;
    context?.markProperty(pointer, 'path');
  }
}

class StrReplace extends SessionEventDataLegacySessionTimelineArguments2 {
  const StrReplace({
    required this.command,
    required this.oldStr,
    required this.path,
    this.newStr,
  }) : super();

  factory StrReplace.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final command = json['command'] as String;
    remaining.remove('command');
    final newStr = json['new_str'] as String?;
    remaining.remove('new_str');
    final oldStr = json['old_str'] as String;
    remaining.remove('old_str');
    final path = json['path'] as String;
    remaining.remove('path');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return StrReplace(
      command: command,
      newStr: newStr,
      oldStr: oldStr,
      path: path,
    );
  }

  /// Constraints: const: str_replace
  final String command;
  final String? newStr;
  final String oldStr;
  final String path;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['command'] = command;
    if (newStr != null) map['new_str'] = newStr;
    map['old_str'] = oldStr;
    map['path'] = path;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'command');
    final value0 = command;
    context?.markProperty(pointer, 'command');
    final actualp0 = value0;
    if (actualp0 != 'str_replace') {
      throwValidationError(
        ptr0,
        'const',
        "Expected value equal to 'str_replace' but found " + actualp0 + '.',
      );
    }
    final ptr1 = appendJsonPointer(pointer, 'new_str');
    final value1 = newStr;
    if (value1 != null) {
      context?.markProperty(pointer, 'new_str');
    }
    final ptr2 = appendJsonPointer(pointer, 'old_str');
    final value2 = oldStr;
    context?.markProperty(pointer, 'old_str');
    final ptr3 = appendJsonPointer(pointer, 'path');
    final value3 = path;
    context?.markProperty(pointer, 'path');
  }
}

class Insert extends SessionEventDataLegacySessionTimelineArguments2 {
  const Insert({
    required this.command,
    required this.insertLine,
    required this.newStr,
    required this.path,
  }) : super();

  factory Insert.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final command = json['command'] as String;
    remaining.remove('command');
    final insertLine = json['insert_line'] as double;
    remaining.remove('insert_line');
    final newStr = json['new_str'] as String;
    remaining.remove('new_str');
    final path = json['path'] as String;
    remaining.remove('path');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Insert(
      command: command,
      insertLine: insertLine,
      newStr: newStr,
      path: path,
    );
  }

  /// Constraints: const: insert
  final String command;
  final double insertLine;
  final String newStr;
  final String path;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['command'] = command;
    map['insert_line'] = insertLine;
    map['new_str'] = newStr;
    map['path'] = path;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'command');
    final value0 = command;
    context?.markProperty(pointer, 'command');
    final actualp0 = value0;
    if (actualp0 != 'insert') {
      throwValidationError(
        ptr0,
        'const',
        "Expected value equal to 'insert' but found " + actualp0 + '.',
      );
    }
    final ptr1 = appendJsonPointer(pointer, 'insert_line');
    final value1 = insertLine;
    context?.markProperty(pointer, 'insert_line');
    final ptr2 = appendJsonPointer(pointer, 'new_str');
    final value2 = newStr;
    context?.markProperty(pointer, 'new_str');
    final ptr3 = appendJsonPointer(pointer, 'path');
    final value3 = path;
    context?.markProperty(pointer, 'path');
  }
}

sealed class SessionEventDataLegacySessionTimelineArguments2 {
  const SessionEventDataLegacySessionTimelineArguments2();

  factory SessionEventDataLegacySessionTimelineArguments2.fromJson(
    Map<String, dynamic> json,
  ) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches =
        <
          SessionEventDataLegacySessionTimelineArguments2 Function(
            Map<String, dynamic>,
          )
        >[];
    final constMatchNames = <String>[];
    if (json['command'] == 'view') {
      constMatches.add(View.fromJson);
      constMatchNames.add('View');
    }
    if (json['command'] == 'create') {
      constMatches.add(Create.fromJson);
      constMatchNames.add('Create');
    }
    if (json['command'] == 'str_replace') {
      constMatches.add(StrReplace.fromJson);
      constMatchNames.add('StrReplace');
    }
    if (json['command'] == 'insert') {
      constMatches.add(Insert.fromJson);
      constMatchNames.add('Insert');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionTimelineArguments2 variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <
          SessionEventDataLegacySessionTimelineArguments2 Function(
            Map<String, dynamic>,
          )
        >[];
    final requiredMatchNames = <String>[];
    if (keys.contains('command') && keys.contains('path')) {
      requiredMatches.add(View.fromJson);
      requiredMatchNames.add('View');
    }
    if (keys.contains('command') &&
        keys.contains('path') &&
        keys.contains('file_text')) {
      requiredMatches.add(Create.fromJson);
      requiredMatchNames.add('Create');
    }
    if (keys.contains('command') &&
        keys.contains('path') &&
        keys.contains('old_str')) {
      requiredMatches.add(StrReplace.fromJson);
      requiredMatchNames.add('StrReplace');
    }
    if (keys.contains('command') &&
        keys.contains('path') &&
        keys.contains('insert_line') &&
        keys.contains('new_str')) {
      requiredMatches.add(Insert.fromJson);
      requiredMatchNames.add('Insert');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionTimelineArguments2 variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No SessionEventDataLegacySessionTimelineArguments2 variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

sealed class ToolCallRequestedArguments {
  const ToolCallRequestedArguments();

  factory ToolCallRequestedArguments.fromJson(dynamic json) {
    if (json is Map<String, dynamic>) {
      return ToolCallRequestedArgumentsSessionEventDataLegacySessionTimelineArguments(
        SessionEventDataLegacySessionTimelineArguments.fromJson(
          (json as Map).cast<String, dynamic>(),
        ),
      );
    }
    if (json is Map<String, dynamic>) {
      return ToolCallRequestedArgumentsSessionEventDataLegacySessionTimelineArguments2(
        SessionEventDataLegacySessionTimelineArguments2.fromJson(
          (json as Map).cast<String, dynamic>(),
        ),
      );
    }
    throw ArgumentError(
      'Invalid ToolCallRequestedArguments value type: ${json.runtimeType}',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  dynamic toJson();
}

class ToolCallRequestedArgumentsSessionEventDataLegacySessionTimelineArguments
    extends ToolCallRequestedArguments {
  const ToolCallRequestedArgumentsSessionEventDataLegacySessionTimelineArguments(
    this.value,
  ) : super();
  final SessionEventDataLegacySessionTimelineArguments value;

  @override
  dynamic toJson() => value.toJson();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolCallRequestedArgumentsSessionEventDataLegacySessionTimelineArguments2
    extends ToolCallRequestedArguments {
  const ToolCallRequestedArgumentsSessionEventDataLegacySessionTimelineArguments2(
    this.value,
  ) : super();
  final SessionEventDataLegacySessionTimelineArguments2 value;

  @override
  dynamic toJson() => value.toJson();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolCallRequestedArgumentsValue extends ToolCallRequestedArguments {
  const ToolCallRequestedArgumentsValue(this.value) : super();
  final dynamic value;

  @override
  dynamic toJson() => value;

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolCallRequested extends SessionEventDataLegacySessionTimeline {
  const ToolCallRequested({
    required this.callId,
    required this.name,
    required this.type,
    this.arguments,
    this.intentionSummary,
    this.isAlwaysExpanded,
    this.isHidden,
    this.partialOutput,
    this.showNoContent,
    this.toolTitle,
  }) : super();

  factory ToolCallRequested.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final arguments = json['arguments'] == null
        ? null
        : ToolCallRequestedArguments.fromJson(
            (json['arguments'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('arguments');
    final callId = json['callId'] as String;
    remaining.remove('callId');
    final intentionSummary = json['intentionSummary'] as String?;
    remaining.remove('intentionSummary');
    final isAlwaysExpanded = json['isAlwaysExpanded'] as bool?;
    remaining.remove('isAlwaysExpanded');
    final isHidden = json['isHidden'] as bool?;
    remaining.remove('isHidden');
    final name = json['name'] as String;
    remaining.remove('name');
    final partialOutput = json['partialOutput'] as String?;
    remaining.remove('partialOutput');
    final showNoContent = json['showNoContent'] as bool?;
    remaining.remove('showNoContent');
    final toolTitle = json['toolTitle'] as String?;
    remaining.remove('toolTitle');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolCallRequested(
      arguments: arguments,
      callId: callId,
      intentionSummary: intentionSummary,
      isAlwaysExpanded: isAlwaysExpanded,
      isHidden: isHidden,
      name: name,
      partialOutput: partialOutput,
      showNoContent: showNoContent,
      toolTitle: toolTitle,
      type: type,
    );
  }
  final ToolCallRequestedArguments? arguments;
  final String callId;

  /// Constraints: types: [string, null]
  final String? intentionSummary;
  final bool? isAlwaysExpanded;
  final bool? isHidden;
  final String name;
  final String? partialOutput;
  final bool? showNoContent;
  final String? toolTitle;

  /// Constraints: const: tool_call_requested
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (arguments != null) map['arguments'] = arguments!.toJson();
    map['callId'] = callId;
    if (intentionSummary != null) map['intentionSummary'] = intentionSummary;
    if (isAlwaysExpanded != null) map['isAlwaysExpanded'] = isAlwaysExpanded;
    if (isHidden != null) map['isHidden'] = isHidden;
    map['name'] = name;
    if (partialOutput != null) map['partialOutput'] = partialOutput;
    if (showNoContent != null) map['showNoContent'] = showNoContent;
    if (toolTitle != null) map['toolTitle'] = toolTitle;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'arguments');
    final value0 = arguments;
    if (value0 != null) {
      context?.markProperty(pointer, 'arguments');
      final jsonp0 = value0.toJson();
      final constraintp0c0_0 = context == null ? null : ValidationContext();
      var constraintp0m0_0 = false;
      try {
        final context = constraintp0c0_0;
        final constraintp0v0_0 =
            SessionEventDataLegacySessionTimelineArguments.fromJson(
              (jsonp0 as Map).cast<String, dynamic>(),
            );
        final jsonp0c0b0 = constraintp0v0_0.toJson();
        final constraintp0c0b0c0_0 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b0m0_0 = false;
        try {
          final context = constraintp0c0b0c0_0;
          final constraintp0c0b0v0_0 =
              SessionEventDataLegacySessionTimelineArgumentsObject.fromJson(
                (jsonp0c0b0 as Map).cast<String, dynamic>(),
              );
          constraintp0c0b0m0_0 = true;
        } catch (_) {}
        final constraintp0c0b0c0_1 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b0m0_1 = false;
        try {
          final context = constraintp0c0b0c0_1;
          final constraintp0c0b0v0_1 =
              SessionEventDataLegacySessionTimelineArgumentsObject2.fromJson(
                (jsonp0c0b0 as Map).cast<String, dynamic>(),
              );
          constraintp0c0b0m0_1 = true;
        } catch (_) {}
        final constraintp0c0b0c0_2 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b0m0_2 = false;
        try {
          final context = constraintp0c0b0c0_2;
          final constraintp0c0b0v0_2 =
              SessionEventDataLegacySessionTimelineArgumentsObject3.fromJson(
                (jsonp0c0b0 as Map).cast<String, dynamic>(),
              );
          constraintp0c0b0m0_2 = true;
        } catch (_) {}
        final constraintp0c0b0c0_3 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b0m0_3 = false;
        try {
          final context = constraintp0c0b0c0_3;
          final constraintp0c0b0v0_3 =
              SessionEventDataLegacySessionTimelineArgumentsObject4.fromJson(
                (jsonp0c0b0 as Map).cast<String, dynamic>(),
              );
          constraintp0c0b0m0_3 = true;
        } catch (_) {}
        final constraintp0c0b0matches0 = <bool>[
          constraintp0c0b0m0_0,
          constraintp0c0b0m0_1,
          constraintp0c0b0m0_2,
          constraintp0c0b0m0_3,
        ];
        if (!constraintp0c0b0matches0.any((value) => value)) {
          throwValidationError(
            ptr0,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf/0/anyOf/5/properties/arguments/anyOf/0/anyOf to validate.',
          );
        }
        if (context != null &&
            constraintp0c0b0m0_0 &&
            constraintp0c0b0c0_0 != null) {
          context.mergeFrom(constraintp0c0b0c0_0!);
        }
        if (context != null &&
            constraintp0c0b0m0_1 &&
            constraintp0c0b0c0_1 != null) {
          context.mergeFrom(constraintp0c0b0c0_1!);
        }
        if (context != null &&
            constraintp0c0b0m0_2 &&
            constraintp0c0b0c0_2 != null) {
          context.mergeFrom(constraintp0c0b0c0_2!);
        }
        if (context != null &&
            constraintp0c0b0m0_3 &&
            constraintp0c0b0c0_3 != null) {
          context.mergeFrom(constraintp0c0b0c0_3!);
        }
        constraintp0m0_0 = true;
      } catch (_) {}
      final constraintp0c0_1 = context == null ? null : ValidationContext();
      var constraintp0m0_1 = false;
      try {
        final context = constraintp0c0_1;
        final constraintp0v0_1 =
            SessionEventDataLegacySessionTimelineArguments2.fromJson(
              (jsonp0 as Map).cast<String, dynamic>(),
            );
        final jsonp0c0b1 = constraintp0v0_1.toJson();
        final constraintp0c0b1c0_0 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1m0_0 = false;
        try {
          final context = constraintp0c0b1c0_0;
          final constraintp0c0b1v0_0 = View.fromJson(
            (jsonp0c0b1 as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1v0_0.validate(pointer: ptr0, context: context);
          constraintp0c0b1m0_0 = true;
        } catch (_) {}
        final constraintp0c0b1c0_1 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1m0_1 = false;
        try {
          final context = constraintp0c0b1c0_1;
          final constraintp0c0b1v0_1 = Create.fromJson(
            (jsonp0c0b1 as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1v0_1.validate(pointer: ptr0, context: context);
          constraintp0c0b1m0_1 = true;
        } catch (_) {}
        final constraintp0c0b1c0_2 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1m0_2 = false;
        try {
          final context = constraintp0c0b1c0_2;
          final constraintp0c0b1v0_2 = StrReplace.fromJson(
            (jsonp0c0b1 as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1v0_2.validate(pointer: ptr0, context: context);
          constraintp0c0b1m0_2 = true;
        } catch (_) {}
        final constraintp0c0b1c0_3 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1m0_3 = false;
        try {
          final context = constraintp0c0b1c0_3;
          final constraintp0c0b1v0_3 = Insert.fromJson(
            (jsonp0c0b1 as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1v0_3.validate(pointer: ptr0, context: context);
          constraintp0c0b1m0_3 = true;
        } catch (_) {}
        final constraintp0c0b1matches0 = <bool>[
          constraintp0c0b1m0_0,
          constraintp0c0b1m0_1,
          constraintp0c0b1m0_2,
          constraintp0c0b1m0_3,
        ];
        if (!constraintp0c0b1matches0.any((value) => value)) {
          throwValidationError(
            ptr0,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf/0/anyOf/5/properties/arguments/anyOf/1/anyOf to validate.',
          );
        }
        if (context != null &&
            constraintp0c0b1m0_0 &&
            constraintp0c0b1c0_0 != null) {
          context.mergeFrom(constraintp0c0b1c0_0!);
        }
        if (context != null &&
            constraintp0c0b1m0_1 &&
            constraintp0c0b1c0_1 != null) {
          context.mergeFrom(constraintp0c0b1c0_1!);
        }
        if (context != null &&
            constraintp0c0b1m0_2 &&
            constraintp0c0b1c0_2 != null) {
          context.mergeFrom(constraintp0c0b1c0_2!);
        }
        if (context != null &&
            constraintp0c0b1m0_3 &&
            constraintp0c0b1c0_3 != null) {
          context.mergeFrom(constraintp0c0b1c0_3!);
        }
        constraintp0m0_1 = true;
      } catch (_) {}
      final constraintp0c0_2 = context == null ? null : ValidationContext();
      var constraintp0m0_2 = false;
      try {
        final context = constraintp0c0_2;
        final constraintp0v0_2 = jsonp0;
        constraintp0m0_2 = true;
      } catch (_) {}
      final constraintp0matches0 = <bool>[
        constraintp0m0_0,
        constraintp0m0_1,
        constraintp0m0_2,
      ];
      if (!constraintp0matches0.any((value) => value)) {
        throwValidationError(
          ptr0,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf/0/anyOf/5/properties/arguments/anyOf to validate.',
        );
      }
      if (context != null && constraintp0m0_0 && constraintp0c0_0 != null) {
        context.mergeFrom(constraintp0c0_0!);
      }
      if (context != null && constraintp0m0_1 && constraintp0c0_1 != null) {
        context.mergeFrom(constraintp0c0_1!);
      }
      if (context != null && constraintp0m0_2 && constraintp0c0_2 != null) {
        context.mergeFrom(constraintp0c0_2!);
      }
    }
    final ptr1 = appendJsonPointer(pointer, 'callId');
    final value1 = callId;
    context?.markProperty(pointer, 'callId');
    final ptr2 = appendJsonPointer(pointer, 'intentionSummary');
    final value2 = intentionSummary;
    if (value2 != null) {
      context?.markProperty(pointer, 'intentionSummary');
    }
    final ptr3 = appendJsonPointer(pointer, 'isAlwaysExpanded');
    final value3 = isAlwaysExpanded;
    if (value3 != null) {
      context?.markProperty(pointer, 'isAlwaysExpanded');
    }
    final ptr4 = appendJsonPointer(pointer, 'isHidden');
    final value4 = isHidden;
    if (value4 != null) {
      context?.markProperty(pointer, 'isHidden');
    }
    final ptr5 = appendJsonPointer(pointer, 'name');
    final value5 = name;
    context?.markProperty(pointer, 'name');
    final ptr6 = appendJsonPointer(pointer, 'partialOutput');
    final value6 = partialOutput;
    if (value6 != null) {
      context?.markProperty(pointer, 'partialOutput');
    }
    final ptr7 = appendJsonPointer(pointer, 'showNoContent');
    final value7 = showNoContent;
    if (value7 != null) {
      context?.markProperty(pointer, 'showNoContent');
    }
    final ptr8 = appendJsonPointer(pointer, 'toolTitle');
    final value8 = toolTitle;
    if (value8 != null) {
      context?.markProperty(pointer, 'toolTitle');
    }
    final ptr9 = appendJsonPointer(pointer, 'type');
    final value9 = type;
    context?.markProperty(pointer, 'type');
    final actualp9 = value9;
    if (actualp9 != 'tool_call_requested') {
      throwValidationError(
        ptr9,
        'const',
        "Expected value equal to 'tool_call_requested' but found " +
            actualp9 +
            '.',
      );
    }
  }
}

class SessionEventDataLegacySessionTimelineArgumentsObject5
    extends SessionEventDataLegacySessionTimelineArguments3 {
  const SessionEventDataLegacySessionTimelineArgumentsObject5({
    required this.command,
    required this.description,
    this.async_,
    this.sessionId,
    this.timeout,
  }) : super();

  factory SessionEventDataLegacySessionTimelineArgumentsObject5.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final async_ = json['async'] as bool?;
    remaining.remove('async');
    final command = json['command'] as String;
    remaining.remove('command');
    final description = json['description'] as String;
    remaining.remove('description');
    final sessionId = json['sessionId'] as String?;
    remaining.remove('sessionId');
    final timeout = json['timeout'] as double?;
    remaining.remove('timeout');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionEventDataLegacySessionTimelineArgumentsObject5(
      async_: async_,
      command: command,
      description: description,
      sessionId: sessionId,
      timeout: timeout,
    );
  }
  final bool? async_;
  final String command;
  final String description;
  final String? sessionId;
  final double? timeout;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (async_ != null) map['async'] = async_;
    map['command'] = command;
    map['description'] = description;
    if (sessionId != null) map['sessionId'] = sessionId;
    if (timeout != null) map['timeout'] = timeout;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionEventDataLegacySessionTimelineArgumentsObject6
    extends SessionEventDataLegacySessionTimelineArguments3 {
  const SessionEventDataLegacySessionTimelineArgumentsObject6({
    required this.input,
    required this.sessionId,
    this.delay,
  }) : super();

  factory SessionEventDataLegacySessionTimelineArgumentsObject6.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final delay = json['delay'] as double?;
    remaining.remove('delay');
    final input = json['input'] as String;
    remaining.remove('input');
    final sessionId = json['sessionId'] as String;
    remaining.remove('sessionId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionEventDataLegacySessionTimelineArgumentsObject6(
      delay: delay,
      input: input,
      sessionId: sessionId,
    );
  }
  final double? delay;
  final String input;
  final String sessionId;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (delay != null) map['delay'] = delay;
    map['input'] = input;
    map['sessionId'] = sessionId;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionEventDataLegacySessionTimelineArgumentsObject7
    extends SessionEventDataLegacySessionTimelineArguments3 {
  const SessionEventDataLegacySessionTimelineArgumentsObject7({
    required this.delay,
    required this.sessionId,
  }) : super();

  factory SessionEventDataLegacySessionTimelineArgumentsObject7.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final delay = json['delay'] as double;
    remaining.remove('delay');
    final sessionId = json['sessionId'] as String;
    remaining.remove('sessionId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionEventDataLegacySessionTimelineArgumentsObject7(
      delay: delay,
      sessionId: sessionId,
    );
  }
  final double delay;
  final String sessionId;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['delay'] = delay;
    map['sessionId'] = sessionId;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionEventDataLegacySessionTimelineArgumentsObject8
    extends SessionEventDataLegacySessionTimelineArguments3 {
  const SessionEventDataLegacySessionTimelineArgumentsObject8({
    required this.sessionId,
  }) : super();

  factory SessionEventDataLegacySessionTimelineArgumentsObject8.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final sessionId = json['sessionId'] as String;
    remaining.remove('sessionId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionEventDataLegacySessionTimelineArgumentsObject8(
      sessionId: sessionId,
    );
  }
  final String sessionId;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['sessionId'] = sessionId;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

sealed class SessionEventDataLegacySessionTimelineArguments3 {
  const SessionEventDataLegacySessionTimelineArguments3();

  factory SessionEventDataLegacySessionTimelineArguments3.fromJson(
    Map<String, dynamic> json,
  ) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final requiredMatches =
        <
          SessionEventDataLegacySessionTimelineArguments3 Function(
            Map<String, dynamic>,
          )
        >[];
    final requiredMatchNames = <String>[];
    if (keys.contains('command') && keys.contains('description')) {
      requiredMatches.add(
        SessionEventDataLegacySessionTimelineArgumentsObject5.fromJson,
      );
      requiredMatchNames.add(
        'SessionEventDataLegacySessionTimelineArgumentsObject5',
      );
    }
    if (keys.contains('sessionId') && keys.contains('input')) {
      requiredMatches.add(
        SessionEventDataLegacySessionTimelineArgumentsObject6.fromJson,
      );
      requiredMatchNames.add(
        'SessionEventDataLegacySessionTimelineArgumentsObject6',
      );
    }
    if (keys.contains('sessionId') && keys.contains('delay')) {
      requiredMatches.add(
        SessionEventDataLegacySessionTimelineArgumentsObject7.fromJson,
      );
      requiredMatchNames.add(
        'SessionEventDataLegacySessionTimelineArgumentsObject7',
      );
    }
    if (keys.contains('sessionId')) {
      requiredMatches.add(
        SessionEventDataLegacySessionTimelineArgumentsObject8.fromJson,
      );
      requiredMatchNames.add(
        'SessionEventDataLegacySessionTimelineArgumentsObject8',
      );
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionTimelineArguments3 variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No SessionEventDataLegacySessionTimelineArguments3 variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

class View2 extends SessionEventDataLegacySessionTimelineArguments4 {
  const View2({
    required this.command,
    required this.path,
    this.viewRange,
  }) : super();

  factory View2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final command = json['command'] as String;
    remaining.remove('command');
    final path = json['path'] as String;
    remaining.remove('path');
    final viewRange = json['view_range'] == null
        ? null
        : (json['view_range'] as List).map((e) => e).toList();
    remaining.remove('view_range');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return View2(
      command: command,
      path: path,
      viewRange: viewRange,
    );
  }

  /// Constraints: const: view
  final String command;
  final String path;

  /// Constraints: minItems: 2, maxItems: 2
  final List<dynamic>? viewRange;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['command'] = command;
    map['path'] = path;
    if (viewRange != null) map['view_range'] = viewRange;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'command');
    final value0 = command;
    context?.markProperty(pointer, 'command');
    final actualp0 = value0;
    if (actualp0 != 'view') {
      throwValidationError(
        ptr0,
        'const',
        "Expected value equal to 'view' but found " + actualp0 + '.',
      );
    }
    final ptr1 = appendJsonPointer(pointer, 'path');
    final value1 = path;
    context?.markProperty(pointer, 'path');
    final ptr2 = appendJsonPointer(pointer, 'view_range');
    final value2 = viewRange;
    if (value2 != null) {
      context?.markProperty(pointer, 'view_range');
      if (value2.length < 2) {
        throwValidationError(
          ptr2,
          'minItems',
          'Expected at least 2 items but found ${value2.length}.',
        );
      }
      if (value2.length > 2) {
        throwValidationError(
          ptr2,
          'maxItems',
          'Expected at most 2 items but found ${value2.length}.',
        );
      }
    }
  }
}

class Create2 extends SessionEventDataLegacySessionTimelineArguments4 {
  const Create2({
    required this.command,
    required this.fileText,
    required this.path,
  }) : super();

  factory Create2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final command = json['command'] as String;
    remaining.remove('command');
    final fileText = json['file_text'] as String;
    remaining.remove('file_text');
    final path = json['path'] as String;
    remaining.remove('path');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Create2(
      command: command,
      fileText: fileText,
      path: path,
    );
  }

  /// Constraints: const: create
  final String command;
  final String fileText;
  final String path;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['command'] = command;
    map['file_text'] = fileText;
    map['path'] = path;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'command');
    final value0 = command;
    context?.markProperty(pointer, 'command');
    final actualp0 = value0;
    if (actualp0 != 'create') {
      throwValidationError(
        ptr0,
        'const',
        "Expected value equal to 'create' but found " + actualp0 + '.',
      );
    }
    final ptr1 = appendJsonPointer(pointer, 'file_text');
    final value1 = fileText;
    context?.markProperty(pointer, 'file_text');
    final ptr2 = appendJsonPointer(pointer, 'path');
    final value2 = path;
    context?.markProperty(pointer, 'path');
  }
}

class StrReplace2 extends SessionEventDataLegacySessionTimelineArguments4 {
  const StrReplace2({
    required this.command,
    required this.oldStr,
    required this.path,
    this.newStr,
  }) : super();

  factory StrReplace2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final command = json['command'] as String;
    remaining.remove('command');
    final newStr = json['new_str'] as String?;
    remaining.remove('new_str');
    final oldStr = json['old_str'] as String;
    remaining.remove('old_str');
    final path = json['path'] as String;
    remaining.remove('path');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return StrReplace2(
      command: command,
      newStr: newStr,
      oldStr: oldStr,
      path: path,
    );
  }

  /// Constraints: const: str_replace
  final String command;
  final String? newStr;
  final String oldStr;
  final String path;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['command'] = command;
    if (newStr != null) map['new_str'] = newStr;
    map['old_str'] = oldStr;
    map['path'] = path;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'command');
    final value0 = command;
    context?.markProperty(pointer, 'command');
    final actualp0 = value0;
    if (actualp0 != 'str_replace') {
      throwValidationError(
        ptr0,
        'const',
        "Expected value equal to 'str_replace' but found " + actualp0 + '.',
      );
    }
    final ptr1 = appendJsonPointer(pointer, 'new_str');
    final value1 = newStr;
    if (value1 != null) {
      context?.markProperty(pointer, 'new_str');
    }
    final ptr2 = appendJsonPointer(pointer, 'old_str');
    final value2 = oldStr;
    context?.markProperty(pointer, 'old_str');
    final ptr3 = appendJsonPointer(pointer, 'path');
    final value3 = path;
    context?.markProperty(pointer, 'path');
  }
}

class Insert2 extends SessionEventDataLegacySessionTimelineArguments4 {
  const Insert2({
    required this.command,
    required this.insertLine,
    required this.newStr,
    required this.path,
  }) : super();

  factory Insert2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final command = json['command'] as String;
    remaining.remove('command');
    final insertLine = json['insert_line'] as double;
    remaining.remove('insert_line');
    final newStr = json['new_str'] as String;
    remaining.remove('new_str');
    final path = json['path'] as String;
    remaining.remove('path');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Insert2(
      command: command,
      insertLine: insertLine,
      newStr: newStr,
      path: path,
    );
  }

  /// Constraints: const: insert
  final String command;
  final double insertLine;
  final String newStr;
  final String path;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['command'] = command;
    map['insert_line'] = insertLine;
    map['new_str'] = newStr;
    map['path'] = path;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'command');
    final value0 = command;
    context?.markProperty(pointer, 'command');
    final actualp0 = value0;
    if (actualp0 != 'insert') {
      throwValidationError(
        ptr0,
        'const',
        "Expected value equal to 'insert' but found " + actualp0 + '.',
      );
    }
    final ptr1 = appendJsonPointer(pointer, 'insert_line');
    final value1 = insertLine;
    context?.markProperty(pointer, 'insert_line');
    final ptr2 = appendJsonPointer(pointer, 'new_str');
    final value2 = newStr;
    context?.markProperty(pointer, 'new_str');
    final ptr3 = appendJsonPointer(pointer, 'path');
    final value3 = path;
    context?.markProperty(pointer, 'path');
  }
}

sealed class SessionEventDataLegacySessionTimelineArguments4 {
  const SessionEventDataLegacySessionTimelineArguments4();

  factory SessionEventDataLegacySessionTimelineArguments4.fromJson(
    Map<String, dynamic> json,
  ) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches =
        <
          SessionEventDataLegacySessionTimelineArguments4 Function(
            Map<String, dynamic>,
          )
        >[];
    final constMatchNames = <String>[];
    if (json['command'] == 'view') {
      constMatches.add(View2.fromJson);
      constMatchNames.add('View2');
    }
    if (json['command'] == 'create') {
      constMatches.add(Create2.fromJson);
      constMatchNames.add('Create2');
    }
    if (json['command'] == 'str_replace') {
      constMatches.add(StrReplace2.fromJson);
      constMatchNames.add('StrReplace2');
    }
    if (json['command'] == 'insert') {
      constMatches.add(Insert2.fromJson);
      constMatchNames.add('Insert2');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionTimelineArguments4 variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <
          SessionEventDataLegacySessionTimelineArguments4 Function(
            Map<String, dynamic>,
          )
        >[];
    final requiredMatchNames = <String>[];
    if (keys.contains('command') && keys.contains('path')) {
      requiredMatches.add(View2.fromJson);
      requiredMatchNames.add('View2');
    }
    if (keys.contains('command') &&
        keys.contains('path') &&
        keys.contains('file_text')) {
      requiredMatches.add(Create2.fromJson);
      requiredMatchNames.add('Create2');
    }
    if (keys.contains('command') &&
        keys.contains('path') &&
        keys.contains('old_str')) {
      requiredMatches.add(StrReplace2.fromJson);
      requiredMatchNames.add('StrReplace2');
    }
    if (keys.contains('command') &&
        keys.contains('path') &&
        keys.contains('insert_line') &&
        keys.contains('new_str')) {
      requiredMatches.add(Insert2.fromJson);
      requiredMatchNames.add('Insert2');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionTimelineArguments4 variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No SessionEventDataLegacySessionTimelineArguments4 variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

sealed class ToolCallCompletedArguments {
  const ToolCallCompletedArguments();

  factory ToolCallCompletedArguments.fromJson(dynamic json) {
    if (json is Map<String, dynamic>) {
      return ToolCallCompletedArgumentsSessionEventDataLegacySessionTimelineArguments3(
        SessionEventDataLegacySessionTimelineArguments3.fromJson(
          (json as Map).cast<String, dynamic>(),
        ),
      );
    }
    if (json is Map<String, dynamic>) {
      return ToolCallCompletedArgumentsSessionEventDataLegacySessionTimelineArguments4(
        SessionEventDataLegacySessionTimelineArguments4.fromJson(
          (json as Map).cast<String, dynamic>(),
        ),
      );
    }
    throw ArgumentError(
      'Invalid ToolCallCompletedArguments value type: ${json.runtimeType}',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  dynamic toJson();
}

class ToolCallCompletedArgumentsSessionEventDataLegacySessionTimelineArguments3
    extends ToolCallCompletedArguments {
  const ToolCallCompletedArgumentsSessionEventDataLegacySessionTimelineArguments3(
    this.value,
  ) : super();
  final SessionEventDataLegacySessionTimelineArguments3 value;

  @override
  dynamic toJson() => value.toJson();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolCallCompletedArgumentsSessionEventDataLegacySessionTimelineArguments4
    extends ToolCallCompletedArguments {
  const ToolCallCompletedArgumentsSessionEventDataLegacySessionTimelineArguments4(
    this.value,
  ) : super();
  final SessionEventDataLegacySessionTimelineArguments4 value;

  @override
  dynamic toJson() => value.toJson();

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolCallCompletedArgumentsValue extends ToolCallCompletedArguments {
  const ToolCallCompletedArgumentsValue(this.value) : super();
  final dynamic value;

  @override
  dynamic toJson() => value;

  @override
  void validate({String pointer = '', ValidationContext? context}) {}
}

class Success extends ToolCallCompletedResult {
  const Success({
    required this.log,
    required this.type,
    this.detailedLog,
    this.markdown,
  }) : super();

  factory Success.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final detailedLog = json['detailedLog'] as String?;
    remaining.remove('detailedLog');
    final log = json['log'] as String;
    remaining.remove('log');
    final markdown = json['markdown'] as bool?;
    remaining.remove('markdown');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Success(
      detailedLog: detailedLog,
      log: log,
      markdown: markdown,
      type: type,
    );
  }
  final String? detailedLog;
  final String log;
  final bool? markdown;

  /// Constraints: const: success
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (detailedLog != null) map['detailedLog'] = detailedLog;
    map['log'] = log;
    if (markdown != null) map['markdown'] = markdown;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'detailedLog');
    final value0 = detailedLog;
    if (value0 != null) {
      context?.markProperty(pointer, 'detailedLog');
    }
    final ptr1 = appendJsonPointer(pointer, 'log');
    final value1 = log;
    context?.markProperty(pointer, 'log');
    final ptr2 = appendJsonPointer(pointer, 'markdown');
    final value2 = markdown;
    if (value2 != null) {
      context?.markProperty(pointer, 'markdown');
    }
    final ptr3 = appendJsonPointer(pointer, 'type');
    final value3 = type;
    context?.markProperty(pointer, 'type');
    final actualp3 = value3;
    if (actualp3 != 'success') {
      throwValidationError(
        ptr3,
        'const',
        "Expected value equal to 'success' but found " + actualp3 + '.',
      );
    }
  }
}

class Failure extends ToolCallCompletedResult {
  const Failure({
    required this.log,
    required this.type,
    this.markdown,
  }) : super();

  factory Failure.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final log = json['log'] as String;
    remaining.remove('log');
    final markdown = json['markdown'] as bool?;
    remaining.remove('markdown');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Failure(
      log: log,
      markdown: markdown,
      type: type,
    );
  }
  final String log;
  final bool? markdown;

  /// Constraints: const: failure
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['log'] = log;
    if (markdown != null) map['markdown'] = markdown;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'log');
    final value0 = log;
    context?.markProperty(pointer, 'log');
    final ptr1 = appendJsonPointer(pointer, 'markdown');
    final value1 = markdown;
    if (value1 != null) {
      context?.markProperty(pointer, 'markdown');
    }
    final ptr2 = appendJsonPointer(pointer, 'type');
    final value2 = type;
    context?.markProperty(pointer, 'type');
    final actualp2 = value2;
    if (actualp2 != 'failure') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'failure' but found " + actualp2 + '.',
      );
    }
  }
}

class Rejected extends ToolCallCompletedResult {
  const Rejected({
    required this.type,
    this.markdown,
  }) : super();

  factory Rejected.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final markdown = json['markdown'] as bool?;
    remaining.remove('markdown');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Rejected(
      markdown: markdown,
      type: type,
    );
  }
  final bool? markdown;

  /// Constraints: const: rejected
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (markdown != null) map['markdown'] = markdown;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'markdown');
    final value0 = markdown;
    if (value0 != null) {
      context?.markProperty(pointer, 'markdown');
    }
    final ptr1 = appendJsonPointer(pointer, 'type');
    final value1 = type;
    context?.markProperty(pointer, 'type');
    final actualp1 = value1;
    if (actualp1 != 'rejected') {
      throwValidationError(
        ptr1,
        'const',
        "Expected value equal to 'rejected' but found " + actualp1 + '.',
      );
    }
  }
}

class Denied extends ToolCallCompletedResult {
  const Denied({
    required this.log,
    required this.type,
    this.markdown,
  }) : super();

  factory Denied.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final log = json['log'] as String;
    remaining.remove('log');
    final markdown = json['markdown'] as bool?;
    remaining.remove('markdown');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Denied(
      log: log,
      markdown: markdown,
      type: type,
    );
  }
  final String log;
  final bool? markdown;

  /// Constraints: const: denied
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['log'] = log;
    if (markdown != null) map['markdown'] = markdown;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'log');
    final value0 = log;
    context?.markProperty(pointer, 'log');
    final ptr1 = appendJsonPointer(pointer, 'markdown');
    final value1 = markdown;
    if (value1 != null) {
      context?.markProperty(pointer, 'markdown');
    }
    final ptr2 = appendJsonPointer(pointer, 'type');
    final value2 = type;
    context?.markProperty(pointer, 'type');
    final actualp2 = value2;
    if (actualp2 != 'denied') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'denied' but found " + actualp2 + '.',
      );
    }
  }
}

sealed class ToolCallCompletedResult {
  const ToolCallCompletedResult();

  factory ToolCallCompletedResult.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches =
        <ToolCallCompletedResult Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['type'] == 'success') {
      constMatches.add(Success.fromJson);
      constMatchNames.add('Success');
    }
    if (json['type'] == 'failure') {
      constMatches.add(Failure.fromJson);
      constMatchNames.add('Failure');
    }
    if (json['type'] == 'rejected') {
      constMatches.add(Rejected.fromJson);
      constMatchNames.add('Rejected');
    }
    if (json['type'] == 'denied') {
      constMatches.add(Denied.fromJson);
      constMatchNames.add('Denied');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous ToolCallCompletedResult variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <ToolCallCompletedResult Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('type') && keys.contains('log')) {
      requiredMatches.add(Success.fromJson);
      requiredMatchNames.add('Success');
    }
    if (keys.contains('type') && keys.contains('log')) {
      requiredMatches.add(Failure.fromJson);
      requiredMatchNames.add('Failure');
    }
    if (keys.contains('type')) {
      requiredMatches.add(Rejected.fromJson);
      requiredMatchNames.add('Rejected');
    }
    if (keys.contains('type') && keys.contains('log')) {
      requiredMatches.add(Denied.fromJson);
      requiredMatchNames.add('Denied');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous ToolCallCompletedResult variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No ToolCallCompletedResult variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

class ToolCallCompleted extends SessionEventDataLegacySessionTimeline {
  const ToolCallCompleted({
    required this.callId,
    required this.name,
    required this.result,
    required this.type,
    this.arguments,
    this.intentionSummary,
    this.isAlwaysExpanded,
    this.isHidden,
    this.showNoContent,
    this.toolTitle,
  }) : super();

  factory ToolCallCompleted.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final arguments = json['arguments'] == null
        ? null
        : ToolCallCompletedArguments.fromJson(
            (json['arguments'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('arguments');
    final callId = json['callId'] as String;
    remaining.remove('callId');
    final intentionSummary = json['intentionSummary'] as String?;
    remaining.remove('intentionSummary');
    final isAlwaysExpanded = json['isAlwaysExpanded'] as bool?;
    remaining.remove('isAlwaysExpanded');
    final isHidden = json['isHidden'] as bool?;
    remaining.remove('isHidden');
    final name = json['name'] as String;
    remaining.remove('name');
    final result = ToolCallCompletedResult.fromJson(
      (json['result'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('result');
    final showNoContent = json['showNoContent'] as bool?;
    remaining.remove('showNoContent');
    final toolTitle = json['toolTitle'] as String?;
    remaining.remove('toolTitle');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolCallCompleted(
      arguments: arguments,
      callId: callId,
      intentionSummary: intentionSummary,
      isAlwaysExpanded: isAlwaysExpanded,
      isHidden: isHidden,
      name: name,
      result: result,
      showNoContent: showNoContent,
      toolTitle: toolTitle,
      type: type,
    );
  }
  final ToolCallCompletedArguments? arguments;
  final String callId;

  /// Constraints: types: [string, null]
  final String? intentionSummary;
  final bool? isAlwaysExpanded;
  final bool? isHidden;
  final String name;
  final ToolCallCompletedResult result;
  final bool? showNoContent;
  final String? toolTitle;

  /// Constraints: const: tool_call_completed
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (arguments != null) map['arguments'] = arguments!.toJson();
    map['callId'] = callId;
    if (intentionSummary != null) map['intentionSummary'] = intentionSummary;
    if (isAlwaysExpanded != null) map['isAlwaysExpanded'] = isAlwaysExpanded;
    if (isHidden != null) map['isHidden'] = isHidden;
    map['name'] = name;
    map['result'] = result.toJson();
    if (showNoContent != null) map['showNoContent'] = showNoContent;
    if (toolTitle != null) map['toolTitle'] = toolTitle;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'arguments');
    final value0 = arguments;
    if (value0 != null) {
      context?.markProperty(pointer, 'arguments');
      final jsonp0 = value0.toJson();
      final constraintp0c0_0 = context == null ? null : ValidationContext();
      var constraintp0m0_0 = false;
      try {
        final context = constraintp0c0_0;
        final constraintp0v0_0 =
            SessionEventDataLegacySessionTimelineArguments3.fromJson(
              (jsonp0 as Map).cast<String, dynamic>(),
            );
        final jsonp0c0b0 = constraintp0v0_0.toJson();
        final constraintp0c0b0c0_0 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b0m0_0 = false;
        try {
          final context = constraintp0c0b0c0_0;
          final constraintp0c0b0v0_0 =
              SessionEventDataLegacySessionTimelineArgumentsObject5.fromJson(
                (jsonp0c0b0 as Map).cast<String, dynamic>(),
              );
          constraintp0c0b0m0_0 = true;
        } catch (_) {}
        final constraintp0c0b0c0_1 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b0m0_1 = false;
        try {
          final context = constraintp0c0b0c0_1;
          final constraintp0c0b0v0_1 =
              SessionEventDataLegacySessionTimelineArgumentsObject6.fromJson(
                (jsonp0c0b0 as Map).cast<String, dynamic>(),
              );
          constraintp0c0b0m0_1 = true;
        } catch (_) {}
        final constraintp0c0b0c0_2 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b0m0_2 = false;
        try {
          final context = constraintp0c0b0c0_2;
          final constraintp0c0b0v0_2 =
              SessionEventDataLegacySessionTimelineArgumentsObject7.fromJson(
                (jsonp0c0b0 as Map).cast<String, dynamic>(),
              );
          constraintp0c0b0m0_2 = true;
        } catch (_) {}
        final constraintp0c0b0c0_3 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b0m0_3 = false;
        try {
          final context = constraintp0c0b0c0_3;
          final constraintp0c0b0v0_3 =
              SessionEventDataLegacySessionTimelineArgumentsObject8.fromJson(
                (jsonp0c0b0 as Map).cast<String, dynamic>(),
              );
          constraintp0c0b0m0_3 = true;
        } catch (_) {}
        final constraintp0c0b0matches0 = <bool>[
          constraintp0c0b0m0_0,
          constraintp0c0b0m0_1,
          constraintp0c0b0m0_2,
          constraintp0c0b0m0_3,
        ];
        if (!constraintp0c0b0matches0.any((value) => value)) {
          throwValidationError(
            ptr0,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf/0/anyOf/6/properties/arguments/anyOf/0/anyOf to validate.',
          );
        }
        if (context != null &&
            constraintp0c0b0m0_0 &&
            constraintp0c0b0c0_0 != null) {
          context.mergeFrom(constraintp0c0b0c0_0!);
        }
        if (context != null &&
            constraintp0c0b0m0_1 &&
            constraintp0c0b0c0_1 != null) {
          context.mergeFrom(constraintp0c0b0c0_1!);
        }
        if (context != null &&
            constraintp0c0b0m0_2 &&
            constraintp0c0b0c0_2 != null) {
          context.mergeFrom(constraintp0c0b0c0_2!);
        }
        if (context != null &&
            constraintp0c0b0m0_3 &&
            constraintp0c0b0c0_3 != null) {
          context.mergeFrom(constraintp0c0b0c0_3!);
        }
        constraintp0m0_0 = true;
      } catch (_) {}
      final constraintp0c0_1 = context == null ? null : ValidationContext();
      var constraintp0m0_1 = false;
      try {
        final context = constraintp0c0_1;
        final constraintp0v0_1 =
            SessionEventDataLegacySessionTimelineArguments4.fromJson(
              (jsonp0 as Map).cast<String, dynamic>(),
            );
        final jsonp0c0b1 = constraintp0v0_1.toJson();
        final constraintp0c0b1c0_0 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1m0_0 = false;
        try {
          final context = constraintp0c0b1c0_0;
          final constraintp0c0b1v0_0 = View2.fromJson(
            (jsonp0c0b1 as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1v0_0.validate(pointer: ptr0, context: context);
          constraintp0c0b1m0_0 = true;
        } catch (_) {}
        final constraintp0c0b1c0_1 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1m0_1 = false;
        try {
          final context = constraintp0c0b1c0_1;
          final constraintp0c0b1v0_1 = Create2.fromJson(
            (jsonp0c0b1 as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1v0_1.validate(pointer: ptr0, context: context);
          constraintp0c0b1m0_1 = true;
        } catch (_) {}
        final constraintp0c0b1c0_2 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1m0_2 = false;
        try {
          final context = constraintp0c0b1c0_2;
          final constraintp0c0b1v0_2 = StrReplace2.fromJson(
            (jsonp0c0b1 as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1v0_2.validate(pointer: ptr0, context: context);
          constraintp0c0b1m0_2 = true;
        } catch (_) {}
        final constraintp0c0b1c0_3 = context == null
            ? null
            : ValidationContext();
        var constraintp0c0b1m0_3 = false;
        try {
          final context = constraintp0c0b1c0_3;
          final constraintp0c0b1v0_3 = Insert2.fromJson(
            (jsonp0c0b1 as Map).cast<String, dynamic>(),
          );
          constraintp0c0b1v0_3.validate(pointer: ptr0, context: context);
          constraintp0c0b1m0_3 = true;
        } catch (_) {}
        final constraintp0c0b1matches0 = <bool>[
          constraintp0c0b1m0_0,
          constraintp0c0b1m0_1,
          constraintp0c0b1m0_2,
          constraintp0c0b1m0_3,
        ];
        if (!constraintp0c0b1matches0.any((value) => value)) {
          throwValidationError(
            ptr0,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf/0/anyOf/6/properties/arguments/anyOf/1/anyOf to validate.',
          );
        }
        if (context != null &&
            constraintp0c0b1m0_0 &&
            constraintp0c0b1c0_0 != null) {
          context.mergeFrom(constraintp0c0b1c0_0!);
        }
        if (context != null &&
            constraintp0c0b1m0_1 &&
            constraintp0c0b1c0_1 != null) {
          context.mergeFrom(constraintp0c0b1c0_1!);
        }
        if (context != null &&
            constraintp0c0b1m0_2 &&
            constraintp0c0b1c0_2 != null) {
          context.mergeFrom(constraintp0c0b1c0_2!);
        }
        if (context != null &&
            constraintp0c0b1m0_3 &&
            constraintp0c0b1c0_3 != null) {
          context.mergeFrom(constraintp0c0b1c0_3!);
        }
        constraintp0m0_1 = true;
      } catch (_) {}
      final constraintp0c0_2 = context == null ? null : ValidationContext();
      var constraintp0m0_2 = false;
      try {
        final context = constraintp0c0_2;
        final constraintp0v0_2 = jsonp0;
        constraintp0m0_2 = true;
      } catch (_) {}
      final constraintp0matches0 = <bool>[
        constraintp0m0_0,
        constraintp0m0_1,
        constraintp0m0_2,
      ];
      if (!constraintp0matches0.any((value) => value)) {
        throwValidationError(
          ptr0,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf/0/anyOf/6/properties/arguments/anyOf to validate.',
        );
      }
      if (context != null && constraintp0m0_0 && constraintp0c0_0 != null) {
        context.mergeFrom(constraintp0c0_0!);
      }
      if (context != null && constraintp0m0_1 && constraintp0c0_1 != null) {
        context.mergeFrom(constraintp0c0_1!);
      }
      if (context != null && constraintp0m0_2 && constraintp0c0_2 != null) {
        context.mergeFrom(constraintp0c0_2!);
      }
    }
    final ptr1 = appendJsonPointer(pointer, 'callId');
    final value1 = callId;
    context?.markProperty(pointer, 'callId');
    final ptr2 = appendJsonPointer(pointer, 'intentionSummary');
    final value2 = intentionSummary;
    if (value2 != null) {
      context?.markProperty(pointer, 'intentionSummary');
    }
    final ptr3 = appendJsonPointer(pointer, 'isAlwaysExpanded');
    final value3 = isAlwaysExpanded;
    if (value3 != null) {
      context?.markProperty(pointer, 'isAlwaysExpanded');
    }
    final ptr4 = appendJsonPointer(pointer, 'isHidden');
    final value4 = isHidden;
    if (value4 != null) {
      context?.markProperty(pointer, 'isHidden');
    }
    final ptr5 = appendJsonPointer(pointer, 'name');
    final value5 = name;
    context?.markProperty(pointer, 'name');
    final ptr6 = appendJsonPointer(pointer, 'result');
    final value6 = result;
    context?.markProperty(pointer, 'result');
    final jsonp6 = value6.toJson();
    final constraintp6c0_0 = context == null ? null : ValidationContext();
    var constraintp6m0_0 = false;
    try {
      final context = constraintp6c0_0;
      final constraintp6v0_0 = Success.fromJson(
        (jsonp6 as Map).cast<String, dynamic>(),
      );
      constraintp6v0_0.validate(pointer: ptr6, context: context);
      constraintp6m0_0 = true;
    } catch (_) {}
    final constraintp6c0_1 = context == null ? null : ValidationContext();
    var constraintp6m0_1 = false;
    try {
      final context = constraintp6c0_1;
      final constraintp6v0_1 = Failure.fromJson(
        (jsonp6 as Map).cast<String, dynamic>(),
      );
      constraintp6v0_1.validate(pointer: ptr6, context: context);
      constraintp6m0_1 = true;
    } catch (_) {}
    final constraintp6c0_2 = context == null ? null : ValidationContext();
    var constraintp6m0_2 = false;
    try {
      final context = constraintp6c0_2;
      final constraintp6v0_2 = Rejected.fromJson(
        (jsonp6 as Map).cast<String, dynamic>(),
      );
      constraintp6v0_2.validate(pointer: ptr6, context: context);
      constraintp6m0_2 = true;
    } catch (_) {}
    final constraintp6c0_3 = context == null ? null : ValidationContext();
    var constraintp6m0_3 = false;
    try {
      final context = constraintp6c0_3;
      final constraintp6v0_3 = Denied.fromJson(
        (jsonp6 as Map).cast<String, dynamic>(),
      );
      constraintp6v0_3.validate(pointer: ptr6, context: context);
      constraintp6m0_3 = true;
    } catch (_) {}
    final constraintp6matches0 = <bool>[
      constraintp6m0_0,
      constraintp6m0_1,
      constraintp6m0_2,
      constraintp6m0_3,
    ];
    if (!constraintp6matches0.any((value) => value)) {
      throwValidationError(
        ptr6,
        'anyOf',
        'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf/0/anyOf/6/properties/result/anyOf to validate.',
      );
    }
    if (context != null && constraintp6m0_0 && constraintp6c0_0 != null) {
      context.mergeFrom(constraintp6c0_0!);
    }
    if (context != null && constraintp6m0_1 && constraintp6c0_1 != null) {
      context.mergeFrom(constraintp6c0_1!);
    }
    if (context != null && constraintp6m0_2 && constraintp6c0_2 != null) {
      context.mergeFrom(constraintp6c0_2!);
    }
    if (context != null && constraintp6m0_3 && constraintp6c0_3 != null) {
      context.mergeFrom(constraintp6c0_3!);
    }
    final ptr7 = appendJsonPointer(pointer, 'showNoContent');
    final value7 = showNoContent;
    if (value7 != null) {
      context?.markProperty(pointer, 'showNoContent');
    }
    final ptr8 = appendJsonPointer(pointer, 'toolTitle');
    final value8 = toolTitle;
    if (value8 != null) {
      context?.markProperty(pointer, 'toolTitle');
    }
    final ptr9 = appendJsonPointer(pointer, 'type');
    final value9 = type;
    context?.markProperty(pointer, 'type');
    final actualp9 = value9;
    if (actualp9 != 'tool_call_completed') {
      throwValidationError(
        ptr9,
        'const',
        "Expected value equal to 'tool_call_completed' but found " +
            actualp9 +
            '.',
      );
    }
  }
}

sealed class SessionEventDataLegacySessionTimeline {
  const SessionEventDataLegacySessionTimeline();

  factory SessionEventDataLegacySessionTimeline.fromJson(
    Map<String, dynamic> json,
  ) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches =
        <
          SessionEventDataLegacySessionTimeline Function(Map<String, dynamic>)
        >[];
    final constMatchNames = <String>[];
    if (json['type'] == 'copilot') {
      constMatches.add(Copilot.fromJson);
      constMatchNames.add('Copilot');
    }
    if (json['type'] == 'error') {
      constMatches.add(Error.fromJson);
      constMatchNames.add('Error');
    }
    if (json['type'] == 'info') {
      constMatches.add(Info.fromJson);
      constMatchNames.add('Info');
    }
    if (json['type'] == 'warning') {
      constMatches.add(Warning.fromJson);
      constMatchNames.add('Warning');
    }
    if (json['type'] == 'user') {
      constMatches.add(User2.fromJson);
      constMatchNames.add('User2');
    }
    if (json['type'] == 'tool_call_requested') {
      constMatches.add(ToolCallRequested.fromJson);
      constMatchNames.add('ToolCallRequested');
    }
    if (json['type'] == 'tool_call_completed') {
      constMatches.add(ToolCallCompleted.fromJson);
      constMatchNames.add('ToolCallCompleted');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionTimeline variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <
          SessionEventDataLegacySessionTimeline Function(Map<String, dynamic>)
        >[];
    final requiredMatchNames = <String>[];
    if (keys.contains('type') && keys.contains('text')) {
      requiredMatches.add(Copilot.fromJson);
      requiredMatchNames.add('Copilot');
    }
    if (keys.contains('type') && keys.contains('text')) {
      requiredMatches.add(Error.fromJson);
      requiredMatchNames.add('Error');
    }
    if (keys.contains('type') && keys.contains('text')) {
      requiredMatches.add(Info.fromJson);
      requiredMatchNames.add('Info');
    }
    if (keys.contains('type') && keys.contains('text')) {
      requiredMatches.add(Warning.fromJson);
      requiredMatchNames.add('Warning');
    }
    if (keys.contains('type') && keys.contains('text')) {
      requiredMatches.add(User2.fromJson);
      requiredMatchNames.add('User2');
    }
    if (keys.contains('type') &&
        keys.contains('callId') &&
        keys.contains('name') &&
        keys.contains('intentionSummary')) {
      requiredMatches.add(ToolCallRequested.fromJson);
      requiredMatchNames.add('ToolCallRequested');
    }
    if (keys.contains('type') &&
        keys.contains('callId') &&
        keys.contains('name') &&
        keys.contains('intentionSummary') &&
        keys.contains('result')) {
      requiredMatches.add(ToolCallCompleted.fromJson);
      requiredMatchNames.add('ToolCallCompleted');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous SessionEventDataLegacySessionTimeline variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No SessionEventDataLegacySessionTimeline variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

class SessionEventDataLegacySessionTimeline2 {
  const SessionEventDataLegacySessionTimeline2({
    required this.id,
    required this.timestamp,
  });

  factory SessionEventDataLegacySessionTimeline2.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final id = json['id'] as String;
    remaining.remove('id');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    return SessionEventDataLegacySessionTimeline2(
      id: id,
      timestamp: timestamp,
    );
  }
  final String id;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['id'] = id;
    map['timestamp'] = timestamp;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionImportLegacyDataLegacySession {
  const SessionImportLegacyDataLegacySession({
    required this.chatMessages,
    required this.sessionId,
    required this.startTime,
    required this.timeline,
    this.selectedModel,
  });

  factory SessionImportLegacyDataLegacySession.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final chatMessages = (json['chatMessages'] as List)
        .map(
          (e) => SessionImportLegacyDataLegacySessionChatMessage.fromJson(
            (e as Map).cast<String, dynamic>(),
          ),
        )
        .toList();
    remaining.remove('chatMessages');
    final selectedModel = json['selectedModel'] == null
        ? null
        : SessionImportLegacyDataLegacySessionSelectedModelJson.fromJson(
            json['selectedModel'] as String,
          );
    remaining.remove('selectedModel');
    final sessionId = json['sessionId'] as String;
    remaining.remove('sessionId');
    final startTime = json['startTime'] as String;
    remaining.remove('startTime');
    final timeline = (json['timeline'] as List)
        .map(
          (e) => SessionImportLegacyDataLegacySessionTimelineItem.fromJson(
            (e as Map).cast<String, dynamic>(),
          ),
        )
        .toList();
    remaining.remove('timeline');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionImportLegacyDataLegacySession(
      chatMessages: chatMessages,
      selectedModel: selectedModel,
      sessionId: sessionId,
      startTime: startTime,
      timeline: timeline,
    );
  }
  final List<SessionImportLegacyDataLegacySessionChatMessage> chatMessages;
  final SessionImportLegacyDataLegacySessionSelectedModel? selectedModel;
  final String sessionId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String startTime;
  final List<SessionImportLegacyDataLegacySessionTimelineItem> timeline;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['chatMessages'] = chatMessages.map((e) => e.toJson()).toList();
    if (selectedModel != null) map['selectedModel'] = selectedModel!.toJson();
    map['sessionId'] = sessionId;
    map['startTime'] = startTime;
    map['timeline'] = timeline.map((e) => e.toJson()).toList();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'chatMessages');
    final value0 = chatMessages;
    context?.markProperty(pointer, 'chatMessages');
    final lenp0 = value0.length;
    final evaluatedp0 = List<bool>.filled(lenp0, false);
    for (var i = 0; i < lenp0; i++) {
      final itemPointer = appendJsonPointer(ptr0, i.toString());
      final item = value0[i];
      final jsonp0i = item.toJson();
      final constraintp0ic0_0 = context == null ? null : ValidationContext();
      var constraintp0im0_0 = false;
      try {
        final context = constraintp0ic0_0;
        final constraintp0iv0_0 = Developer.fromJson(
          (jsonp0i as Map).cast<String, dynamic>(),
        );
        constraintp0iv0_0.validate(pointer: itemPointer, context: context);
        constraintp0im0_0 = true;
      } catch (_) {}
      final constraintp0ic0_1 = context == null ? null : ValidationContext();
      var constraintp0im0_1 = false;
      try {
        final context = constraintp0ic0_1;
        final constraintp0iv0_1 = System.fromJson(
          (jsonp0i as Map).cast<String, dynamic>(),
        );
        constraintp0iv0_1.validate(pointer: itemPointer, context: context);
        constraintp0im0_1 = true;
      } catch (_) {}
      final constraintp0ic0_2 = context == null ? null : ValidationContext();
      var constraintp0im0_2 = false;
      try {
        final context = constraintp0ic0_2;
        final constraintp0iv0_2 = User.fromJson(
          (jsonp0i as Map).cast<String, dynamic>(),
        );
        constraintp0iv0_2.validate(pointer: itemPointer, context: context);
        constraintp0im0_2 = true;
      } catch (_) {}
      final constraintp0ic0_3 = context == null ? null : ValidationContext();
      var constraintp0im0_3 = false;
      try {
        final context = constraintp0ic0_3;
        final constraintp0iv0_3 = Assistant.fromJson(
          (jsonp0i as Map).cast<String, dynamic>(),
        );
        constraintp0iv0_3.validate(pointer: itemPointer, context: context);
        constraintp0im0_3 = true;
      } catch (_) {}
      final constraintp0ic0_4 = context == null ? null : ValidationContext();
      var constraintp0im0_4 = false;
      try {
        final context = constraintp0ic0_4;
        final constraintp0iv0_4 = Tool.fromJson(
          (jsonp0i as Map).cast<String, dynamic>(),
        );
        constraintp0iv0_4.validate(pointer: itemPointer, context: context);
        constraintp0im0_4 = true;
      } catch (_) {}
      final constraintp0ic0_5 = context == null ? null : ValidationContext();
      var constraintp0im0_5 = false;
      try {
        final context = constraintp0ic0_5;
        final constraintp0iv0_5 = Function2.fromJson(
          (jsonp0i as Map).cast<String, dynamic>(),
        );
        constraintp0iv0_5.validate(pointer: itemPointer, context: context);
        constraintp0im0_5 = true;
      } catch (_) {}
      final constraintp0imatches0 = <bool>[
        constraintp0im0_0,
        constraintp0im0_1,
        constraintp0im0_2,
        constraintp0im0_3,
        constraintp0im0_4,
        constraintp0im0_5,
      ];
      if (!constraintp0imatches0.any((value) => value)) {
        throwValidationError(
          itemPointer,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/chatMessages/items/anyOf to validate.',
        );
      }
      if (context != null && constraintp0im0_0 && constraintp0ic0_0 != null) {
        context.mergeFrom(constraintp0ic0_0!);
      }
      if (context != null && constraintp0im0_1 && constraintp0ic0_1 != null) {
        context.mergeFrom(constraintp0ic0_1!);
      }
      if (context != null && constraintp0im0_2 && constraintp0ic0_2 != null) {
        context.mergeFrom(constraintp0ic0_2!);
      }
      if (context != null && constraintp0im0_3 && constraintp0ic0_3 != null) {
        context.mergeFrom(constraintp0ic0_3!);
      }
      if (context != null && constraintp0im0_4 && constraintp0ic0_4 != null) {
        context.mergeFrom(constraintp0ic0_4!);
      }
      if (context != null && constraintp0im0_5 && constraintp0ic0_5 != null) {
        context.mergeFrom(constraintp0ic0_5!);
      }
      evaluatedp0[i] = true;
      context?.markItem(ptr0, i);
    }
    final ptr1 = appendJsonPointer(pointer, 'selectedModel');
    final value1 = selectedModel;
    if (value1 != null) {
      context?.markProperty(pointer, 'selectedModel');
    }
    final ptr2 = appendJsonPointer(pointer, 'sessionId');
    final value2 = sessionId;
    context?.markProperty(pointer, 'sessionId');
    final ptr3 = appendJsonPointer(pointer, 'startTime');
    final value3 = startTime;
    context?.markProperty(pointer, 'startTime');
    final ptr4 = appendJsonPointer(pointer, 'timeline');
    final value4 = timeline;
    context?.markProperty(pointer, 'timeline');
    final lenp4 = value4.length;
    final evaluatedp4 = List<bool>.filled(lenp4, false);
    for (var i = 0; i < lenp4; i++) {
      final itemPointer = appendJsonPointer(ptr4, i.toString());
      final item = value4[i];
      final jsonp4i = item.toJson();
      final constraintp4ic0_0 = context == null ? null : ValidationContext();
      var constraintp4im0_0 = false;
      try {
        final context = constraintp4ic0_0;
        final constraintp4iv0_0 =
            SessionEventDataLegacySessionTimeline.fromJson(
              (jsonp4i as Map).cast<String, dynamic>(),
            );
        final jsonp4ic0b0 = constraintp4iv0_0.toJson();
        final constraintp4ic0b0c0_0 = context == null
            ? null
            : ValidationContext();
        var constraintp4ic0b0m0_0 = false;
        try {
          final context = constraintp4ic0b0c0_0;
          final constraintp4ic0b0v0_0 = Copilot.fromJson(
            (jsonp4ic0b0 as Map).cast<String, dynamic>(),
          );
          constraintp4ic0b0v0_0.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp4ic0b0m0_0 = true;
        } catch (_) {}
        final constraintp4ic0b0c0_1 = context == null
            ? null
            : ValidationContext();
        var constraintp4ic0b0m0_1 = false;
        try {
          final context = constraintp4ic0b0c0_1;
          final constraintp4ic0b0v0_1 = Error.fromJson(
            (jsonp4ic0b0 as Map).cast<String, dynamic>(),
          );
          constraintp4ic0b0v0_1.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp4ic0b0m0_1 = true;
        } catch (_) {}
        final constraintp4ic0b0c0_2 = context == null
            ? null
            : ValidationContext();
        var constraintp4ic0b0m0_2 = false;
        try {
          final context = constraintp4ic0b0c0_2;
          final constraintp4ic0b0v0_2 = Info.fromJson(
            (jsonp4ic0b0 as Map).cast<String, dynamic>(),
          );
          constraintp4ic0b0v0_2.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp4ic0b0m0_2 = true;
        } catch (_) {}
        final constraintp4ic0b0c0_3 = context == null
            ? null
            : ValidationContext();
        var constraintp4ic0b0m0_3 = false;
        try {
          final context = constraintp4ic0b0c0_3;
          final constraintp4ic0b0v0_3 = Warning.fromJson(
            (jsonp4ic0b0 as Map).cast<String, dynamic>(),
          );
          constraintp4ic0b0v0_3.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp4ic0b0m0_3 = true;
        } catch (_) {}
        final constraintp4ic0b0c0_4 = context == null
            ? null
            : ValidationContext();
        var constraintp4ic0b0m0_4 = false;
        try {
          final context = constraintp4ic0b0c0_4;
          final constraintp4ic0b0v0_4 = User2.fromJson(
            (jsonp4ic0b0 as Map).cast<String, dynamic>(),
          );
          constraintp4ic0b0v0_4.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp4ic0b0m0_4 = true;
        } catch (_) {}
        final constraintp4ic0b0c0_5 = context == null
            ? null
            : ValidationContext();
        var constraintp4ic0b0m0_5 = false;
        try {
          final context = constraintp4ic0b0c0_5;
          final constraintp4ic0b0v0_5 = ToolCallRequested.fromJson(
            (jsonp4ic0b0 as Map).cast<String, dynamic>(),
          );
          constraintp4ic0b0v0_5.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp4ic0b0m0_5 = true;
        } catch (_) {}
        final constraintp4ic0b0c0_6 = context == null
            ? null
            : ValidationContext();
        var constraintp4ic0b0m0_6 = false;
        try {
          final context = constraintp4ic0b0c0_6;
          final constraintp4ic0b0v0_6 = ToolCallCompleted.fromJson(
            (jsonp4ic0b0 as Map).cast<String, dynamic>(),
          );
          constraintp4ic0b0v0_6.validate(
            pointer: itemPointer,
            context: context,
          );
          constraintp4ic0b0m0_6 = true;
        } catch (_) {}
        final constraintp4ic0b0matches0 = <bool>[
          constraintp4ic0b0m0_0,
          constraintp4ic0b0m0_1,
          constraintp4ic0b0m0_2,
          constraintp4ic0b0m0_3,
          constraintp4ic0b0m0_4,
          constraintp4ic0b0m0_5,
          constraintp4ic0b0m0_6,
        ];
        if (!constraintp4ic0b0matches0.any((value) => value)) {
          throwValidationError(
            itemPointer,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf/0/anyOf to validate.',
          );
        }
        if (context != null &&
            constraintp4ic0b0m0_0 &&
            constraintp4ic0b0c0_0 != null) {
          context.mergeFrom(constraintp4ic0b0c0_0!);
        }
        if (context != null &&
            constraintp4ic0b0m0_1 &&
            constraintp4ic0b0c0_1 != null) {
          context.mergeFrom(constraintp4ic0b0c0_1!);
        }
        if (context != null &&
            constraintp4ic0b0m0_2 &&
            constraintp4ic0b0c0_2 != null) {
          context.mergeFrom(constraintp4ic0b0c0_2!);
        }
        if (context != null &&
            constraintp4ic0b0m0_3 &&
            constraintp4ic0b0c0_3 != null) {
          context.mergeFrom(constraintp4ic0b0c0_3!);
        }
        if (context != null &&
            constraintp4ic0b0m0_4 &&
            constraintp4ic0b0c0_4 != null) {
          context.mergeFrom(constraintp4ic0b0c0_4!);
        }
        if (context != null &&
            constraintp4ic0b0m0_5 &&
            constraintp4ic0b0c0_5 != null) {
          context.mergeFrom(constraintp4ic0b0c0_5!);
        }
        if (context != null &&
            constraintp4ic0b0m0_6 &&
            constraintp4ic0b0c0_6 != null) {
          context.mergeFrom(constraintp4ic0b0c0_6!);
        }
        constraintp4im0_0 = true;
      } catch (_) {}
      final constraintp4ic0_1 = context == null ? null : ValidationContext();
      var constraintp4im0_1 = false;
      try {
        final context = constraintp4ic0_1;
        final constraintp4iv0_1 =
            SessionEventDataLegacySessionTimeline2.fromJson(
              (jsonp4i as Map).cast<String, dynamic>(),
            );
        constraintp4im0_1 = true;
      } catch (_) {}
      final constraintp4imatches0 = <bool>[
        constraintp4im0_0,
        constraintp4im0_1,
      ];
      if (constraintp4imatches0.any((value) => !value)) {
        throwValidationError(
          itemPointer,
          'allOf',
          'Expected all subschemas in #/definitions/SessionEvent/anyOf/6/properties/data/properties/legacySession/properties/timeline/items/allOf to validate.',
        );
      }
      if (context != null && constraintp4im0_0 && constraintp4ic0_0 != null) {
        context.mergeFrom(constraintp4ic0_0!);
      }
      if (context != null && constraintp4im0_1 && constraintp4ic0_1 != null) {
        context.mergeFrom(constraintp4ic0_1!);
      }
      evaluatedp4[i] = true;
      context?.markItem(ptr4, i);
    }
  }
}

class SessionImportLegacyData {
  const SessionImportLegacyData({
    required this.importTime,
    required this.legacySession,
    required this.sourceFile,
  });

  factory SessionImportLegacyData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final importTime = json['importTime'] as String;
    remaining.remove('importTime');
    final legacySession = SessionImportLegacyDataLegacySession.fromJson(
      (json['legacySession'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('legacySession');
    final sourceFile = json['sourceFile'] as String;
    remaining.remove('sourceFile');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionImportLegacyData(
      importTime: importTime,
      legacySession: legacySession,
      sourceFile: sourceFile,
    );
  }

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String importTime;
  final SessionImportLegacyDataLegacySession legacySession;
  final String sourceFile;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['importTime'] = importTime;
    map['legacySession'] = legacySession.toJson();
    map['sourceFile'] = sourceFile;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'importTime');
    final value0 = importTime;
    context?.markProperty(pointer, 'importTime');
    final ptr1 = appendJsonPointer(pointer, 'legacySession');
    final value1 = legacySession;
    context?.markProperty(pointer, 'legacySession');
    value1.validate(pointer: ptr1, context: context);
    final ptr2 = appendJsonPointer(pointer, 'sourceFile');
    final value2 = sourceFile;
    context?.markProperty(pointer, 'sourceFile');
  }
}

class SessionImportLegacy extends SessionEvent {
  const SessionImportLegacy({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionImportLegacy.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionImportLegacyData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionImportLegacy(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionImportLegacyData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.import_legacy
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    value0.validate(pointer: ptr0, context: context);
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/6/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.import_legacy') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.import_legacy' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class SessionHandoffDataRepository {
  const SessionHandoffDataRepository({
    required this.name,
    required this.owner,
    this.branch,
  });

  factory SessionHandoffDataRepository.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final branch = json['branch'] as String?;
    remaining.remove('branch');
    final name = json['name'] as String;
    remaining.remove('name');
    final owner = json['owner'] as String;
    remaining.remove('owner');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionHandoffDataRepository(
      branch: branch,
      name: name,
      owner: owner,
    );
  }
  final String? branch;
  final String name;
  final String owner;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (branch != null) map['branch'] = branch;
    map['name'] = name;
    map['owner'] = owner;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionHandoffData {
  const SessionHandoffData({
    required this.handoffTime,
    required this.sourceType,
    this.context,
    this.remoteSessionId,
    this.repository,
    this.summary,
  });

  factory SessionHandoffData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final context = json['context'] as String?;
    remaining.remove('context');
    final handoffTime = json['handoffTime'] as String;
    remaining.remove('handoffTime');
    final remoteSessionId = json['remoteSessionId'] as String?;
    remaining.remove('remoteSessionId');
    final repository = json['repository'] == null
        ? null
        : SessionHandoffDataRepository.fromJson(
            (json['repository'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('repository');
    final sourceType = SessionHandoffDataSourceTypeJson.fromJson(
      json['sourceType'] as String,
    );
    remaining.remove('sourceType');
    final summary = json['summary'] as String?;
    remaining.remove('summary');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionHandoffData(
      context: context,
      handoffTime: handoffTime,
      remoteSessionId: remoteSessionId,
      repository: repository,
      sourceType: sourceType,
      summary: summary,
    );
  }
  final String? context;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String handoffTime;
  final String? remoteSessionId;
  final SessionHandoffDataRepository? repository;
  final SessionHandoffDataSourceType sourceType;
  final String? summary;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (context != null) map['context'] = context;
    map['handoffTime'] = handoffTime;
    if (remoteSessionId != null) map['remoteSessionId'] = remoteSessionId;
    if (repository != null) map['repository'] = repository!.toJson();
    map['sourceType'] = sourceType.toJson();
    if (summary != null) map['summary'] = summary;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionHandoff extends SessionEvent {
  const SessionHandoff({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionHandoff.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionHandoffData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionHandoff(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionHandoffData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.handoff
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/7/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.handoff') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.handoff' but found " + actualp5 + '.',
      );
    }
  }
}

class SessionTruncationData {
  const SessionTruncationData({
    required this.messagesRemovedDuringTruncation,
    required this.performedBy,
    required this.postTruncationMessagesLength,
    required this.postTruncationTokensInMessages,
    required this.preTruncationMessagesLength,
    required this.preTruncationTokensInMessages,
    required this.tokenLimit,
    required this.tokensRemovedDuringTruncation,
  });

  factory SessionTruncationData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final messagesRemovedDuringTruncation =
        json['messagesRemovedDuringTruncation'] as double;
    remaining.remove('messagesRemovedDuringTruncation');
    final performedBy = json['performedBy'] as String;
    remaining.remove('performedBy');
    final postTruncationMessagesLength =
        json['postTruncationMessagesLength'] as double;
    remaining.remove('postTruncationMessagesLength');
    final postTruncationTokensInMessages =
        json['postTruncationTokensInMessages'] as double;
    remaining.remove('postTruncationTokensInMessages');
    final preTruncationMessagesLength =
        json['preTruncationMessagesLength'] as double;
    remaining.remove('preTruncationMessagesLength');
    final preTruncationTokensInMessages =
        json['preTruncationTokensInMessages'] as double;
    remaining.remove('preTruncationTokensInMessages');
    final tokenLimit = json['tokenLimit'] as double;
    remaining.remove('tokenLimit');
    final tokensRemovedDuringTruncation =
        json['tokensRemovedDuringTruncation'] as double;
    remaining.remove('tokensRemovedDuringTruncation');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionTruncationData(
      messagesRemovedDuringTruncation: messagesRemovedDuringTruncation,
      performedBy: performedBy,
      postTruncationMessagesLength: postTruncationMessagesLength,
      postTruncationTokensInMessages: postTruncationTokensInMessages,
      preTruncationMessagesLength: preTruncationMessagesLength,
      preTruncationTokensInMessages: preTruncationTokensInMessages,
      tokenLimit: tokenLimit,
      tokensRemovedDuringTruncation: tokensRemovedDuringTruncation,
    );
  }
  final double messagesRemovedDuringTruncation;
  final String performedBy;
  final double postTruncationMessagesLength;
  final double postTruncationTokensInMessages;
  final double preTruncationMessagesLength;
  final double preTruncationTokensInMessages;
  final double tokenLimit;
  final double tokensRemovedDuringTruncation;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['messagesRemovedDuringTruncation'] = messagesRemovedDuringTruncation;
    map['performedBy'] = performedBy;
    map['postTruncationMessagesLength'] = postTruncationMessagesLength;
    map['postTruncationTokensInMessages'] = postTruncationTokensInMessages;
    map['preTruncationMessagesLength'] = preTruncationMessagesLength;
    map['preTruncationTokensInMessages'] = preTruncationTokensInMessages;
    map['tokenLimit'] = tokenLimit;
    map['tokensRemovedDuringTruncation'] = tokensRemovedDuringTruncation;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionTruncation extends SessionEvent {
  const SessionTruncation({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionTruncation.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionTruncationData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionTruncation(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionTruncationData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.truncation
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/8/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.truncation') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.truncation' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class SessionSnapshotRewindData {
  const SessionSnapshotRewindData({
    required this.eventsRemoved,
    required this.upToEventId,
  });

  factory SessionSnapshotRewindData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final eventsRemoved = json['eventsRemoved'] as double;
    remaining.remove('eventsRemoved');
    final upToEventId = json['upToEventId'] as String;
    remaining.remove('upToEventId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionSnapshotRewindData(
      eventsRemoved: eventsRemoved,
      upToEventId: upToEventId,
    );
  }
  final double eventsRemoved;
  final String upToEventId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['eventsRemoved'] = eventsRemoved;
    map['upToEventId'] = upToEventId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionSnapshotRewind extends SessionEvent {
  const SessionSnapshotRewind({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory SessionSnapshotRewind.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionSnapshotRewindData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionSnapshotRewind(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionSnapshotRewindData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.snapshot_rewind
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/9/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.snapshot_rewind') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.snapshot_rewind' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class SessionUsageInfoData {
  const SessionUsageInfoData({
    required this.currentTokens,
    required this.messagesLength,
    required this.tokenLimit,
  });

  factory SessionUsageInfoData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final currentTokens = json['currentTokens'] as double;
    remaining.remove('currentTokens');
    final messagesLength = json['messagesLength'] as double;
    remaining.remove('messagesLength');
    final tokenLimit = json['tokenLimit'] as double;
    remaining.remove('tokenLimit');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionUsageInfoData(
      currentTokens: currentTokens,
      messagesLength: messagesLength,
      tokenLimit: tokenLimit,
    );
  }
  final double currentTokens;
  final double messagesLength;
  final double tokenLimit;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['currentTokens'] = currentTokens;
    map['messagesLength'] = messagesLength;
    map['tokenLimit'] = tokenLimit;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionUsageInfo extends SessionEvent {
  const SessionUsageInfo({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory SessionUsageInfo.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionUsageInfoData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionUsageInfo(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionUsageInfoData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.usage_info
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/10/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.usage_info') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.usage_info' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class SessionCompactionStartData {
  const SessionCompactionStartData();

  factory SessionCompactionStartData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return const SessionCompactionStartData();
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionCompactionStart extends SessionEvent {
  const SessionCompactionStart({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionCompactionStart.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionCompactionStartData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionCompactionStart(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionCompactionStartData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.compaction_start
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/11/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.compaction_start') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.compaction_start' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class SessionCompactionCompleteDataCompactionTokensUsed {
  const SessionCompactionCompleteDataCompactionTokensUsed({
    required this.cachedInput,
    required this.input,
    required this.output,
  });

  factory SessionCompactionCompleteDataCompactionTokensUsed.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final cachedInput = json['cachedInput'] as double;
    remaining.remove('cachedInput');
    final input = json['input'] as double;
    remaining.remove('input');
    final output = json['output'] as double;
    remaining.remove('output');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionCompactionCompleteDataCompactionTokensUsed(
      cachedInput: cachedInput,
      input: input,
      output: output,
    );
  }
  final double cachedInput;
  final double input;
  final double output;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['cachedInput'] = cachedInput;
    map['input'] = input;
    map['output'] = output;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionCompactionCompleteData {
  const SessionCompactionCompleteData({
    required this.success,
    this.checkpointNumber,
    this.checkpointPath,
    this.compactionTokensUsed,
    this.error,
    this.messagesRemoved,
    this.postCompactionTokens,
    this.preCompactionMessagesLength,
    this.preCompactionTokens,
    this.summaryContent,
    this.tokensRemoved,
  });

  factory SessionCompactionCompleteData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final checkpointNumber = json['checkpointNumber'] as double?;
    remaining.remove('checkpointNumber');
    final checkpointPath = json['checkpointPath'] as String?;
    remaining.remove('checkpointPath');
    final compactionTokensUsed = json['compactionTokensUsed'] == null
        ? null
        : SessionCompactionCompleteDataCompactionTokensUsed.fromJson(
            (json['compactionTokensUsed'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('compactionTokensUsed');
    final error = json['error'] as String?;
    remaining.remove('error');
    final messagesRemoved = json['messagesRemoved'] as double?;
    remaining.remove('messagesRemoved');
    final postCompactionTokens = json['postCompactionTokens'] as double?;
    remaining.remove('postCompactionTokens');
    final preCompactionMessagesLength =
        json['preCompactionMessagesLength'] as double?;
    remaining.remove('preCompactionMessagesLength');
    final preCompactionTokens = json['preCompactionTokens'] as double?;
    remaining.remove('preCompactionTokens');
    final success = json['success'] as bool;
    remaining.remove('success');
    final summaryContent = json['summaryContent'] as String?;
    remaining.remove('summaryContent');
    final tokensRemoved = json['tokensRemoved'] as double?;
    remaining.remove('tokensRemoved');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionCompactionCompleteData(
      checkpointNumber: checkpointNumber,
      checkpointPath: checkpointPath,
      compactionTokensUsed: compactionTokensUsed,
      error: error,
      messagesRemoved: messagesRemoved,
      postCompactionTokens: postCompactionTokens,
      preCompactionMessagesLength: preCompactionMessagesLength,
      preCompactionTokens: preCompactionTokens,
      success: success,
      summaryContent: summaryContent,
      tokensRemoved: tokensRemoved,
    );
  }
  final double? checkpointNumber;
  final String? checkpointPath;
  final SessionCompactionCompleteDataCompactionTokensUsed? compactionTokensUsed;
  final String? error;
  final double? messagesRemoved;
  final double? postCompactionTokens;
  final double? preCompactionMessagesLength;
  final double? preCompactionTokens;
  final bool success;
  final String? summaryContent;
  final double? tokensRemoved;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (checkpointNumber != null) map['checkpointNumber'] = checkpointNumber;
    if (checkpointPath != null) map['checkpointPath'] = checkpointPath;
    if (compactionTokensUsed != null) {
      map['compactionTokensUsed'] = compactionTokensUsed!.toJson();
    }
    if (error != null) map['error'] = error;
    if (messagesRemoved != null) map['messagesRemoved'] = messagesRemoved;
    if (postCompactionTokens != null) {
      map['postCompactionTokens'] = postCompactionTokens;
    }
    if (preCompactionMessagesLength != null) {
      map['preCompactionMessagesLength'] = preCompactionMessagesLength;
    }
    if (preCompactionTokens != null) {
      map['preCompactionTokens'] = preCompactionTokens;
    }
    map['success'] = success;
    if (summaryContent != null) map['summaryContent'] = summaryContent;
    if (tokensRemoved != null) map['tokensRemoved'] = tokensRemoved;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionCompactionComplete extends SessionEvent {
  const SessionCompactionComplete({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SessionCompactionComplete.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SessionCompactionCompleteData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionCompactionComplete(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SessionCompactionCompleteData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: session.compaction_complete
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/12/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'session.compaction_complete') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'session.compaction_complete' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class File2 extends UserMessageDataAttachment {
  const File2({
    required this.displayName,
    required this.path,
    required this.type,
  }) : super();

  factory File2.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final displayName = json['displayName'] as String;
    remaining.remove('displayName');
    final path = json['path'] as String;
    remaining.remove('path');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return File2(
      displayName: displayName,
      path: path,
      type: type,
    );
  }
  final String displayName;
  final String path;

  /// Constraints: const: file
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['displayName'] = displayName;
    map['path'] = path;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'displayName');
    final value0 = displayName;
    context?.markProperty(pointer, 'displayName');
    final ptr1 = appendJsonPointer(pointer, 'path');
    final value1 = path;
    context?.markProperty(pointer, 'path');
    final ptr2 = appendJsonPointer(pointer, 'type');
    final value2 = type;
    context?.markProperty(pointer, 'type');
    final actualp2 = value2;
    if (actualp2 != 'file') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'file' but found " + actualp2 + '.',
      );
    }
  }
}

class Directory extends UserMessageDataAttachment {
  const Directory({
    required this.displayName,
    required this.path,
    required this.type,
  }) : super();

  factory Directory.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final displayName = json['displayName'] as String;
    remaining.remove('displayName');
    final path = json['path'] as String;
    remaining.remove('path');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Directory(
      displayName: displayName,
      path: path,
      type: type,
    );
  }
  final String displayName;
  final String path;

  /// Constraints: const: directory
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['displayName'] = displayName;
    map['path'] = path;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'displayName');
    final value0 = displayName;
    context?.markProperty(pointer, 'displayName');
    final ptr1 = appendJsonPointer(pointer, 'path');
    final value1 = path;
    context?.markProperty(pointer, 'path');
    final ptr2 = appendJsonPointer(pointer, 'type');
    final value2 = type;
    context?.markProperty(pointer, 'type');
    final actualp2 = value2;
    if (actualp2 != 'directory') {
      throwValidationError(
        ptr2,
        'const',
        "Expected value equal to 'directory' but found " + actualp2 + '.',
      );
    }
  }
}

class SelectionSelectionEnd {
  const SelectionSelectionEnd({
    required this.character,
    required this.line,
  });

  factory SelectionSelectionEnd.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final character = json['character'] as double;
    remaining.remove('character');
    final line = json['line'] as double;
    remaining.remove('line');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SelectionSelectionEnd(
      character: character,
      line: line,
    );
  }
  final double character;
  final double line;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['character'] = character;
    map['line'] = line;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SessionStartData {
  const SessionStartData({
    required this.copilotVersion,
    required this.producer,
    required this.sessionId,
    required this.startTime,
    required this.version,
    this.context,
    this.selectedModel,
  });

  factory SessionStartData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final context = json['context'] == null
        ? null
        : SessionStartDataContext.fromJson(
            (json['context'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('context');
    final copilotVersion = json['copilotVersion'] as String;
    remaining.remove('copilotVersion');
    final producer = json['producer'] as String;
    remaining.remove('producer');
    final selectedModel = json['selectedModel'] as String?;
    remaining.remove('selectedModel');
    final sessionId = json['sessionId'] as String;
    remaining.remove('sessionId');
    final startTime = json['startTime'] as String;
    remaining.remove('startTime');
    final version = json['version'] as double;
    remaining.remove('version');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SessionStartData(
      context: context,
      copilotVersion: copilotVersion,
      producer: producer,
      selectedModel: selectedModel,
      sessionId: sessionId,
      startTime: startTime,
      version: version,
    );
  }
  final SessionStartDataContext? context;
  final String copilotVersion;
  final String producer;
  final String? selectedModel;
  final String sessionId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String startTime;
  final double version;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (context != null) map['context'] = context!.toJson();
    map['copilotVersion'] = copilotVersion;
    map['producer'] = producer;
    if (selectedModel != null) map['selectedModel'] = selectedModel;
    map['sessionId'] = sessionId;
    map['startTime'] = startTime;
    map['version'] = version;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SelectionSelection {
  const SelectionSelection({
    required this.end,
    required this.start,
  });

  factory SelectionSelection.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final end = SelectionSelectionEnd.fromJson(
      (json['end'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('end');
    final start = SelectionSelectionStart.fromJson(
      (json['start'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('start');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SelectionSelection(
      end: end,
      start: start,
    );
  }
  final SelectionSelectionEnd end;
  final SelectionSelectionStart start;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['end'] = end.toJson();
    map['start'] = start.toJson();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class Selection extends UserMessageDataAttachment {
  const Selection({
    required this.displayName,
    required this.filePath,
    required this.selection,
    required this.text,
    required this.type,
  }) : super();

  factory Selection.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final displayName = json['displayName'] as String;
    remaining.remove('displayName');
    final filePath = json['filePath'] as String;
    remaining.remove('filePath');
    final selection = SelectionSelection.fromJson(
      (json['selection'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('selection');
    final text = json['text'] as String;
    remaining.remove('text');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Selection(
      displayName: displayName,
      filePath: filePath,
      selection: selection,
      text: text,
      type: type,
    );
  }
  final String displayName;
  final String filePath;
  final SelectionSelection selection;
  final String text;

  /// Constraints: const: selection
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['displayName'] = displayName;
    map['filePath'] = filePath;
    map['selection'] = selection.toJson();
    map['text'] = text;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'displayName');
    final value0 = displayName;
    context?.markProperty(pointer, 'displayName');
    final ptr1 = appendJsonPointer(pointer, 'filePath');
    final value1 = filePath;
    context?.markProperty(pointer, 'filePath');
    final ptr2 = appendJsonPointer(pointer, 'selection');
    final value2 = selection;
    context?.markProperty(pointer, 'selection');
    final ptr3 = appendJsonPointer(pointer, 'text');
    final value3 = text;
    context?.markProperty(pointer, 'text');
    final ptr4 = appendJsonPointer(pointer, 'type');
    final value4 = type;
    context?.markProperty(pointer, 'type');
    final actualp4 = value4;
    if (actualp4 != 'selection') {
      throwValidationError(
        ptr4,
        'const',
        "Expected value equal to 'selection' but found " + actualp4 + '.',
      );
    }
  }
}

sealed class UserMessageDataAttachment {
  const UserMessageDataAttachment();

  factory UserMessageDataAttachment.fromJson(Map<String, dynamic> json) {
    final keys = json.keys.toSet();
    final sortedKeys = keys.toList()..sort();
    final constMatches =
        <UserMessageDataAttachment Function(Map<String, dynamic>)>[];
    final constMatchNames = <String>[];
    if (json['type'] == 'file') {
      constMatches.add(File2.fromJson);
      constMatchNames.add('File2');
    }
    if (json['type'] == 'directory') {
      constMatches.add(Directory.fromJson);
      constMatchNames.add('Directory');
    }
    if (json['type'] == 'selection') {
      constMatches.add(Selection.fromJson);
      constMatchNames.add('Selection');
    }
    if (constMatches.length == 1) {
      return constMatches.single(json);
    }
    if (constMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous UserMessageDataAttachment variant matched const heuristics: ${constMatchNames.join(', ')}',
      );
    }
    final requiredMatches =
        <UserMessageDataAttachment Function(Map<String, dynamic>)>[];
    final requiredMatchNames = <String>[];
    if (keys.contains('type') &&
        keys.contains('path') &&
        keys.contains('displayName')) {
      requiredMatches.add(File2.fromJson);
      requiredMatchNames.add('File2');
    }
    if (keys.contains('type') &&
        keys.contains('path') &&
        keys.contains('displayName')) {
      requiredMatches.add(Directory.fromJson);
      requiredMatchNames.add('Directory');
    }
    if (keys.contains('type') &&
        keys.contains('filePath') &&
        keys.contains('displayName') &&
        keys.contains('text') &&
        keys.contains('selection')) {
      requiredMatches.add(Selection.fromJson);
      requiredMatchNames.add('Selection');
    }
    if (requiredMatches.length == 1) {
      return requiredMatches.single(json);
    }
    if (requiredMatches.length > 1) {
      throw ArgumentError(
        'Ambiguous UserMessageDataAttachment variant matched required-property heuristics: ${requiredMatchNames.join(', ')}',
      );
    }
    throw ArgumentError(
      'No UserMessageDataAttachment variant matched heuristics (keys: ${sortedKeys.join(', ')}).',
    );
  }

  void validate({String pointer = '', ValidationContext? context});

  Map<String, dynamic> toJson();
}

class UserMessageData {
  const UserMessageData({
    required this.content,
    this.attachments,
    this.source,
    this.transformedContent,
  });

  factory UserMessageData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final attachments = json['attachments'] == null
        ? null
        : (json['attachments'] as List)
              .map(
                (e) => UserMessageDataAttachment.fromJson(
                  (e as Map).cast<String, dynamic>(),
                ),
              )
              .toList();
    remaining.remove('attachments');
    final content = json['content'] as String;
    remaining.remove('content');
    final source = json['source'] as String?;
    remaining.remove('source');
    final transformedContent = json['transformedContent'] as String?;
    remaining.remove('transformedContent');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return UserMessageData(
      attachments: attachments,
      content: content,
      source: source,
      transformedContent: transformedContent,
    );
  }
  final List<UserMessageDataAttachment>? attachments;
  final String content;
  final String? source;
  final String? transformedContent;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (attachments != null) {
      map['attachments'] = attachments!.map((e) => e.toJson()).toList();
    }
    map['content'] = content;
    if (source != null) map['source'] = source;
    if (transformedContent != null) {
      map['transformedContent'] = transformedContent;
    }
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'attachments');
    final value0 = attachments;
    if (value0 != null) {
      context?.markProperty(pointer, 'attachments');
      final lenp0 = value0.length;
      final evaluatedp0 = List<bool>.filled(lenp0, false);
      for (var i = 0; i < lenp0; i++) {
        final itemPointer = appendJsonPointer(ptr0, i.toString());
        final item = value0[i];
        final jsonp0i = item.toJson();
        final constraintp0ic0_0 = context == null ? null : ValidationContext();
        var constraintp0im0_0 = false;
        try {
          final context = constraintp0ic0_0;
          final constraintp0iv0_0 = File2.fromJson(
            (jsonp0i as Map).cast<String, dynamic>(),
          );
          constraintp0iv0_0.validate(pointer: itemPointer, context: context);
          constraintp0im0_0 = true;
        } catch (_) {}
        final constraintp0ic0_1 = context == null ? null : ValidationContext();
        var constraintp0im0_1 = false;
        try {
          final context = constraintp0ic0_1;
          final constraintp0iv0_1 = Directory.fromJson(
            (jsonp0i as Map).cast<String, dynamic>(),
          );
          constraintp0iv0_1.validate(pointer: itemPointer, context: context);
          constraintp0im0_1 = true;
        } catch (_) {}
        final constraintp0ic0_2 = context == null ? null : ValidationContext();
        var constraintp0im0_2 = false;
        try {
          final context = constraintp0ic0_2;
          final constraintp0iv0_2 = Selection.fromJson(
            (jsonp0i as Map).cast<String, dynamic>(),
          );
          constraintp0iv0_2.validate(pointer: itemPointer, context: context);
          constraintp0im0_2 = true;
        } catch (_) {}
        final constraintp0imatches0 = <bool>[
          constraintp0im0_0,
          constraintp0im0_1,
          constraintp0im0_2,
        ];
        if (!constraintp0imatches0.any((value) => value)) {
          throwValidationError(
            itemPointer,
            'anyOf',
            'Expected at least one subschema in #/definitions/SessionEvent/anyOf/13/properties/data/properties/attachments/items/anyOf to validate.',
          );
        }
        if (context != null && constraintp0im0_0 && constraintp0ic0_0 != null) {
          context.mergeFrom(constraintp0ic0_0!);
        }
        if (context != null && constraintp0im0_1 && constraintp0ic0_1 != null) {
          context.mergeFrom(constraintp0ic0_1!);
        }
        if (context != null && constraintp0im0_2 && constraintp0ic0_2 != null) {
          context.mergeFrom(constraintp0ic0_2!);
        }
        evaluatedp0[i] = true;
        context?.markItem(ptr0, i);
      }
    }
    final ptr1 = appendJsonPointer(pointer, 'content');
    final value1 = content;
    context?.markProperty(pointer, 'content');
    final ptr2 = appendJsonPointer(pointer, 'source');
    final value2 = source;
    if (value2 != null) {
      context?.markProperty(pointer, 'source');
    }
    final ptr3 = appendJsonPointer(pointer, 'transformedContent');
    final value3 = transformedContent;
    if (value3 != null) {
      context?.markProperty(pointer, 'transformedContent');
    }
  }
}

class UserMessage extends SessionEvent {
  const UserMessage({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory UserMessage.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = UserMessageData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return UserMessage(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final UserMessageData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: user.message
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    value0.validate(pointer: ptr0, context: context);
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/13/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'user.message') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'user.message' but found " + actualp5 + '.',
      );
    }
  }
}

class PendingMessagesModifiedData {
  const PendingMessagesModifiedData();

  factory PendingMessagesModifiedData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return const PendingMessagesModifiedData();
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class PendingMessagesModified extends SessionEvent {
  const PendingMessagesModified({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory PendingMessagesModified.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = PendingMessagesModifiedData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return PendingMessagesModified(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final PendingMessagesModifiedData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: pending_messages.modified
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/14/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'pending_messages.modified') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'pending_messages.modified' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class AssistantTurnStartData {
  const AssistantTurnStartData({
    required this.turnId,
  });

  factory AssistantTurnStartData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final turnId = json['turnId'] as String;
    remaining.remove('turnId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantTurnStartData(
      turnId: turnId,
    );
  }
  final String turnId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['turnId'] = turnId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantTurnStart extends SessionEvent {
  const AssistantTurnStart({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory AssistantTurnStart.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AssistantTurnStartData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantTurnStart(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AssistantTurnStartData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: assistant.turn_start
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/15/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'assistant.turn_start') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant.turn_start' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class AssistantIntentData {
  const AssistantIntentData({
    required this.intent,
  });

  factory AssistantIntentData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final intent = json['intent'] as String;
    remaining.remove('intent');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantIntentData(
      intent: intent,
    );
  }
  final String intent;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['intent'] = intent;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantIntent extends SessionEvent {
  const AssistantIntent({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory AssistantIntent.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AssistantIntentData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantIntent(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AssistantIntentData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: assistant.intent
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/16/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'assistant.intent') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant.intent' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class AssistantReasoningData {
  const AssistantReasoningData({
    required this.content,
    required this.reasoningId,
  });

  factory AssistantReasoningData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = json['content'] as String;
    remaining.remove('content');
    final reasoningId = json['reasoningId'] as String;
    remaining.remove('reasoningId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantReasoningData(
      content: content,
      reasoningId: reasoningId,
    );
  }
  final String content;
  final String reasoningId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content;
    map['reasoningId'] = reasoningId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantReasoning extends SessionEvent {
  const AssistantReasoning({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory AssistantReasoning.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AssistantReasoningData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantReasoning(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AssistantReasoningData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: assistant.reasoning
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/17/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'assistant.reasoning') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant.reasoning' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class AssistantReasoningDeltaData {
  const AssistantReasoningDeltaData({
    required this.deltaContent,
    required this.reasoningId,
  });

  factory AssistantReasoningDeltaData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final deltaContent = json['deltaContent'] as String;
    remaining.remove('deltaContent');
    final reasoningId = json['reasoningId'] as String;
    remaining.remove('reasoningId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantReasoningDeltaData(
      deltaContent: deltaContent,
      reasoningId: reasoningId,
    );
  }
  final String deltaContent;
  final String reasoningId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['deltaContent'] = deltaContent;
    map['reasoningId'] = reasoningId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantReasoningDelta extends SessionEvent {
  const AssistantReasoningDelta({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory AssistantReasoningDelta.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AssistantReasoningDeltaData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantReasoningDelta(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AssistantReasoningDeltaData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: assistant.reasoning_delta
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/18/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'assistant.reasoning_delta') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant.reasoning_delta' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class AssistantMessageDataToolRequest {
  const AssistantMessageDataToolRequest({
    required this.name,
    required this.toolCallId,
    this.arguments,
    this.type,
  });

  factory AssistantMessageDataToolRequest.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final arguments = json['arguments'];
    remaining.remove('arguments');
    final name = json['name'] as String;
    remaining.remove('name');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final type = json['type'] == null
        ? null
        : AssistantMessageDataToolRequestTypeJson.fromJson(
            json['type'] as String,
          );
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantMessageDataToolRequest(
      arguments: arguments,
      name: name,
      toolCallId: toolCallId,
      type: type,
    );
  }
  final dynamic arguments;
  final String name;
  final String toolCallId;
  final AssistantMessageDataToolRequestType? type;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (arguments != null) map['arguments'] = arguments;
    map['name'] = name;
    map['toolCallId'] = toolCallId;
    if (type != null) map['type'] = type!.toJson();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantMessageData {
  const AssistantMessageData({
    required this.content,
    required this.messageId,
    this.encryptedContent,
    this.parentToolCallId,
    this.reasoningOpaque,
    this.reasoningText,
    this.toolRequests,
  });

  factory AssistantMessageData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = json['content'] as String;
    remaining.remove('content');
    final encryptedContent = json['encryptedContent'] as String?;
    remaining.remove('encryptedContent');
    final messageId = json['messageId'] as String;
    remaining.remove('messageId');
    final parentToolCallId = json['parentToolCallId'] as String?;
    remaining.remove('parentToolCallId');
    final reasoningOpaque = json['reasoningOpaque'] as String?;
    remaining.remove('reasoningOpaque');
    final reasoningText = json['reasoningText'] as String?;
    remaining.remove('reasoningText');
    final toolRequests = json['toolRequests'] == null
        ? null
        : (json['toolRequests'] as List)
              .map(
                (e) => AssistantMessageDataToolRequest.fromJson(
                  (e as Map).cast<String, dynamic>(),
                ),
              )
              .toList();
    remaining.remove('toolRequests');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantMessageData(
      content: content,
      encryptedContent: encryptedContent,
      messageId: messageId,
      parentToolCallId: parentToolCallId,
      reasoningOpaque: reasoningOpaque,
      reasoningText: reasoningText,
      toolRequests: toolRequests,
    );
  }
  final String content;
  final String? encryptedContent;
  final String messageId;
  final String? parentToolCallId;
  final String? reasoningOpaque;
  final String? reasoningText;
  final List<AssistantMessageDataToolRequest>? toolRequests;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content;
    if (encryptedContent != null) map['encryptedContent'] = encryptedContent;
    map['messageId'] = messageId;
    if (parentToolCallId != null) map['parentToolCallId'] = parentToolCallId;
    if (reasoningOpaque != null) map['reasoningOpaque'] = reasoningOpaque;
    if (reasoningText != null) map['reasoningText'] = reasoningText;
    if (toolRequests != null) {
      map['toolRequests'] = toolRequests!.map((e) => e.toJson()).toList();
    }
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantMessage extends SessionEvent {
  const AssistantMessage({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory AssistantMessage.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AssistantMessageData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantMessage(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AssistantMessageData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: assistant.message
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/19/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'assistant.message') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant.message' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class AssistantMessageDeltaData {
  const AssistantMessageDeltaData({
    required this.deltaContent,
    required this.messageId,
    this.parentToolCallId,
    this.totalResponseSizeBytes,
  });

  factory AssistantMessageDeltaData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final deltaContent = json['deltaContent'] as String;
    remaining.remove('deltaContent');
    final messageId = json['messageId'] as String;
    remaining.remove('messageId');
    final parentToolCallId = json['parentToolCallId'] as String?;
    remaining.remove('parentToolCallId');
    final totalResponseSizeBytes = json['totalResponseSizeBytes'] as double?;
    remaining.remove('totalResponseSizeBytes');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantMessageDeltaData(
      deltaContent: deltaContent,
      messageId: messageId,
      parentToolCallId: parentToolCallId,
      totalResponseSizeBytes: totalResponseSizeBytes,
    );
  }
  final String deltaContent;
  final String messageId;
  final String? parentToolCallId;
  final double? totalResponseSizeBytes;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['deltaContent'] = deltaContent;
    map['messageId'] = messageId;
    if (parentToolCallId != null) map['parentToolCallId'] = parentToolCallId;
    if (totalResponseSizeBytes != null) {
      map['totalResponseSizeBytes'] = totalResponseSizeBytes;
    }
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantMessageDelta extends SessionEvent {
  const AssistantMessageDelta({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory AssistantMessageDelta.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AssistantMessageDeltaData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantMessageDelta(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AssistantMessageDeltaData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: assistant.message_delta
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/20/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'assistant.message_delta') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant.message_delta' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class AssistantTurnEndData {
  const AssistantTurnEndData({
    required this.turnId,
  });

  factory AssistantTurnEndData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final turnId = json['turnId'] as String;
    remaining.remove('turnId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantTurnEndData(
      turnId: turnId,
    );
  }
  final String turnId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['turnId'] = turnId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantTurnEnd extends SessionEvent {
  const AssistantTurnEnd({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory AssistantTurnEnd.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AssistantTurnEndData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantTurnEnd(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AssistantTurnEndData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: assistant.turn_end
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/21/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'assistant.turn_end') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant.turn_end' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class AssistantUsageDataQuotaSnapshotsAdditionalProperty {
  const AssistantUsageDataQuotaSnapshotsAdditionalProperty({
    required this.entitlementRequests,
    required this.isUnlimitedEntitlement,
    required this.overage,
    required this.overageAllowedWithExhaustedQuota,
    required this.remainingPercentage,
    required this.usageAllowedWithExhaustedQuota,
    required this.usedRequests,
    this.resetDate,
  });

  factory AssistantUsageDataQuotaSnapshotsAdditionalProperty.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    final entitlementRequests = json['entitlementRequests'] as double;
    remaining.remove('entitlementRequests');
    final isUnlimitedEntitlement = json['isUnlimitedEntitlement'] as bool;
    remaining.remove('isUnlimitedEntitlement');
    final overage = json['overage'] as double;
    remaining.remove('overage');
    final overageAllowedWithExhaustedQuota =
        json['overageAllowedWithExhaustedQuota'] as bool;
    remaining.remove('overageAllowedWithExhaustedQuota');
    final remainingPercentage = json['remainingPercentage'] as double;
    remaining.remove('remainingPercentage');
    final resetDate = json['resetDate'] as String?;
    remaining.remove('resetDate');
    final usageAllowedWithExhaustedQuota =
        json['usageAllowedWithExhaustedQuota'] as bool;
    remaining.remove('usageAllowedWithExhaustedQuota');
    final usedRequests = json['usedRequests'] as double;
    remaining.remove('usedRequests');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantUsageDataQuotaSnapshotsAdditionalProperty(
      entitlementRequests: entitlementRequests,
      isUnlimitedEntitlement: isUnlimitedEntitlement,
      overage: overage,
      overageAllowedWithExhaustedQuota: overageAllowedWithExhaustedQuota,
      remainingPercentage: remainingPercentage,
      resetDate: resetDate,
      usageAllowedWithExhaustedQuota: usageAllowedWithExhaustedQuota,
      usedRequests: usedRequests,
    );
  }
  final double entitlementRequests;
  final bool isUnlimitedEntitlement;
  final double overage;
  final bool overageAllowedWithExhaustedQuota;
  final double remainingPercentage;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String? resetDate;
  final bool usageAllowedWithExhaustedQuota;
  final double usedRequests;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['entitlementRequests'] = entitlementRequests;
    map['isUnlimitedEntitlement'] = isUnlimitedEntitlement;
    map['overage'] = overage;
    map['overageAllowedWithExhaustedQuota'] = overageAllowedWithExhaustedQuota;
    map['remainingPercentage'] = remainingPercentage;
    if (resetDate != null) map['resetDate'] = resetDate;
    map['usageAllowedWithExhaustedQuota'] = usageAllowedWithExhaustedQuota;
    map['usedRequests'] = usedRequests;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantUsageDataQuotaSnapshots {
  const AssistantUsageDataQuotaSnapshots({
    this.additionalProperties,
  });

  factory AssistantUsageDataQuotaSnapshots.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    var unmatched = Map<String, dynamic>.from(remaining);
    Map<String, AssistantUsageDataQuotaSnapshotsAdditionalProperty>?
    additionalPropertiesValue;
    if (unmatched.isNotEmpty) {
      final additionalPropertiesMap =
          <String, AssistantUsageDataQuotaSnapshotsAdditionalProperty>{};
      for (final entry in unmatched.entries) {
        final value = entry.value;
        additionalPropertiesMap[entry.key] =
            AssistantUsageDataQuotaSnapshotsAdditionalProperty.fromJson(
              (value as Map).cast<String, dynamic>(),
            );
      }
      additionalPropertiesValue = additionalPropertiesMap.isEmpty
          ? null
          : additionalPropertiesMap;
      unmatched = <String, dynamic>{};
    } else {
      additionalPropertiesValue = null;
    }
    return AssistantUsageDataQuotaSnapshots(
      additionalProperties: additionalPropertiesValue,
    );
  }
  final Map<String, AssistantUsageDataQuotaSnapshotsAdditionalProperty>?
  additionalProperties;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (additionalProperties != null) {
      additionalProperties!.forEach((key, value) {
        map[key] = value.toJson();
      });
    }
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantUsageData {
  const AssistantUsageData({
    required this.model,
    this.apiCallId,
    this.cacheReadTokens,
    this.cacheWriteTokens,
    this.cost,
    this.duration,
    this.initiator,
    this.inputTokens,
    this.outputTokens,
    this.parentToolCallId,
    this.providerCallId,
    this.quotaSnapshots,
  });

  factory AssistantUsageData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final apiCallId = json['apiCallId'] as String?;
    remaining.remove('apiCallId');
    final cacheReadTokens = json['cacheReadTokens'] as double?;
    remaining.remove('cacheReadTokens');
    final cacheWriteTokens = json['cacheWriteTokens'] as double?;
    remaining.remove('cacheWriteTokens');
    final cost = json['cost'] as double?;
    remaining.remove('cost');
    final duration = json['duration'] as double?;
    remaining.remove('duration');
    final initiator = json['initiator'] as String?;
    remaining.remove('initiator');
    final inputTokens = json['inputTokens'] as double?;
    remaining.remove('inputTokens');
    final model = json['model'] as String;
    remaining.remove('model');
    final outputTokens = json['outputTokens'] as double?;
    remaining.remove('outputTokens');
    final parentToolCallId = json['parentToolCallId'] as String?;
    remaining.remove('parentToolCallId');
    final providerCallId = json['providerCallId'] as String?;
    remaining.remove('providerCallId');
    final quotaSnapshots = json['quotaSnapshots'] == null
        ? null
        : AssistantUsageDataQuotaSnapshots.fromJson(
            (json['quotaSnapshots'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('quotaSnapshots');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantUsageData(
      apiCallId: apiCallId,
      cacheReadTokens: cacheReadTokens,
      cacheWriteTokens: cacheWriteTokens,
      cost: cost,
      duration: duration,
      initiator: initiator,
      inputTokens: inputTokens,
      model: model,
      outputTokens: outputTokens,
      parentToolCallId: parentToolCallId,
      providerCallId: providerCallId,
      quotaSnapshots: quotaSnapshots,
    );
  }
  final String? apiCallId;
  final double? cacheReadTokens;
  final double? cacheWriteTokens;
  final double? cost;
  final double? duration;
  final String? initiator;
  final double? inputTokens;
  final String model;
  final double? outputTokens;
  final String? parentToolCallId;
  final String? providerCallId;
  final AssistantUsageDataQuotaSnapshots? quotaSnapshots;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (apiCallId != null) map['apiCallId'] = apiCallId;
    if (cacheReadTokens != null) map['cacheReadTokens'] = cacheReadTokens;
    if (cacheWriteTokens != null) map['cacheWriteTokens'] = cacheWriteTokens;
    if (cost != null) map['cost'] = cost;
    if (duration != null) map['duration'] = duration;
    if (initiator != null) map['initiator'] = initiator;
    if (inputTokens != null) map['inputTokens'] = inputTokens;
    map['model'] = model;
    if (outputTokens != null) map['outputTokens'] = outputTokens;
    if (parentToolCallId != null) map['parentToolCallId'] = parentToolCallId;
    if (providerCallId != null) map['providerCallId'] = providerCallId;
    if (quotaSnapshots != null) {
      map['quotaSnapshots'] = quotaSnapshots!.toJson();
    }
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class AssistantUsage extends SessionEvent {
  const AssistantUsage({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory AssistantUsage.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AssistantUsageData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AssistantUsage(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AssistantUsageData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: assistant.usage
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/22/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'assistant.usage') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'assistant.usage' but found " + actualp5 + '.',
      );
    }
  }
}

class AbortData {
  const AbortData({
    required this.reason,
  });

  factory AbortData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final reason = json['reason'] as String;
    remaining.remove('reason');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return AbortData(
      reason: reason,
    );
  }
  final String reason;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['reason'] = reason;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class Abort extends SessionEvent {
  const Abort({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory Abort.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = AbortData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return Abort(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final AbortData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: abort
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/23/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'abort') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'abort' but found " + actualp5 + '.',
      );
    }
  }
}

class ToolUserRequestedData {
  const ToolUserRequestedData({
    required this.toolCallId,
    required this.toolName,
    this.arguments,
  });

  factory ToolUserRequestedData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final arguments = json['arguments'];
    remaining.remove('arguments');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final toolName = json['toolName'] as String;
    remaining.remove('toolName');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolUserRequestedData(
      arguments: arguments,
      toolCallId: toolCallId,
      toolName: toolName,
    );
  }
  final dynamic arguments;
  final String toolCallId;
  final String toolName;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (arguments != null) map['arguments'] = arguments;
    map['toolCallId'] = toolCallId;
    map['toolName'] = toolName;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolUserRequested extends SessionEvent {
  const ToolUserRequested({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory ToolUserRequested.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = ToolUserRequestedData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolUserRequested(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final ToolUserRequestedData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: tool.user_requested
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/24/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'tool.user_requested') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'tool.user_requested' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class ToolExecutionStartData {
  const ToolExecutionStartData({
    required this.toolCallId,
    required this.toolName,
    this.arguments,
    this.mcpServerName,
    this.mcpToolName,
    this.parentToolCallId,
  });

  factory ToolExecutionStartData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final arguments = json['arguments'];
    remaining.remove('arguments');
    final mcpServerName = json['mcpServerName'] as String?;
    remaining.remove('mcpServerName');
    final mcpToolName = json['mcpToolName'] as String?;
    remaining.remove('mcpToolName');
    final parentToolCallId = json['parentToolCallId'] as String?;
    remaining.remove('parentToolCallId');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final toolName = json['toolName'] as String;
    remaining.remove('toolName');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionStartData(
      arguments: arguments,
      mcpServerName: mcpServerName,
      mcpToolName: mcpToolName,
      parentToolCallId: parentToolCallId,
      toolCallId: toolCallId,
      toolName: toolName,
    );
  }
  final dynamic arguments;
  final String? mcpServerName;
  final String? mcpToolName;
  final String? parentToolCallId;
  final String toolCallId;
  final String toolName;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (arguments != null) map['arguments'] = arguments;
    if (mcpServerName != null) map['mcpServerName'] = mcpServerName;
    if (mcpToolName != null) map['mcpToolName'] = mcpToolName;
    if (parentToolCallId != null) map['parentToolCallId'] = parentToolCallId;
    map['toolCallId'] = toolCallId;
    map['toolName'] = toolName;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolExecutionStart extends SessionEvent {
  const ToolExecutionStart({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory ToolExecutionStart.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = ToolExecutionStartData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionStart(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final ToolExecutionStartData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: tool.execution_start
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/25/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'tool.execution_start') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'tool.execution_start' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class ToolExecutionPartialResultData {
  const ToolExecutionPartialResultData({
    required this.partialOutput,
    required this.toolCallId,
  });

  factory ToolExecutionPartialResultData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final partialOutput = json['partialOutput'] as String;
    remaining.remove('partialOutput');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionPartialResultData(
      partialOutput: partialOutput,
      toolCallId: toolCallId,
    );
  }
  final String partialOutput;
  final String toolCallId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['partialOutput'] = partialOutput;
    map['toolCallId'] = toolCallId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolExecutionPartialResult extends SessionEvent {
  const ToolExecutionPartialResult({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory ToolExecutionPartialResult.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = ToolExecutionPartialResultData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionPartialResult(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final ToolExecutionPartialResultData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: tool.execution_partial_result
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/26/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'tool.execution_partial_result') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'tool.execution_partial_result' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class ToolExecutionProgressData {
  const ToolExecutionProgressData({
    required this.progressMessage,
    required this.toolCallId,
  });

  factory ToolExecutionProgressData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final progressMessage = json['progressMessage'] as String;
    remaining.remove('progressMessage');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionProgressData(
      progressMessage: progressMessage,
      toolCallId: toolCallId,
    );
  }
  final String progressMessage;
  final String toolCallId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['progressMessage'] = progressMessage;
    map['toolCallId'] = toolCallId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolExecutionProgress extends SessionEvent {
  const ToolExecutionProgress({
    required this.data,
    required this.ephemeral,
    required this.id,
    required this.timestamp,
    required this.type,
    this.parentId,
  }) : super();

  factory ToolExecutionProgress.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = ToolExecutionProgressData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionProgress(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final ToolExecutionProgressData data;

  /// Constraints: const: true
  final bool ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: tool.execution_progress
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    context?.markProperty(pointer, 'ephemeral');
    final actualp1 = value1;
    if (!actualp1) {
      throwValidationError(
        ptr1,
        'const',
        'Expected value equal to true but found $actualp1.',
      );
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/27/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'tool.execution_progress') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'tool.execution_progress' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class ToolExecutionCompleteDataError {
  const ToolExecutionCompleteDataError({
    required this.message,
    this.code,
  });

  factory ToolExecutionCompleteDataError.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final code = json['code'] as String?;
    remaining.remove('code');
    final message = json['message'] as String;
    remaining.remove('message');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionCompleteDataError(
      code: code,
      message: message,
    );
  }
  final String? code;
  final String message;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (code != null) map['code'] = code;
    map['message'] = message;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolExecutionCompleteDataResult {
  const ToolExecutionCompleteDataResult({
    required this.content,
    this.detailedContent,
  });

  factory ToolExecutionCompleteDataResult.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = json['content'] as String;
    remaining.remove('content');
    final detailedContent = json['detailedContent'] as String?;
    remaining.remove('detailedContent');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionCompleteDataResult(
      content: content,
      detailedContent: detailedContent,
    );
  }
  final String content;
  final String? detailedContent;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content;
    if (detailedContent != null) map['detailedContent'] = detailedContent;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolExecutionCompleteDataToolTelemetry {
  const ToolExecutionCompleteDataToolTelemetry({
    this.additionalProperties,
  });

  factory ToolExecutionCompleteDataToolTelemetry.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    var unmatched = Map<String, dynamic>.from(remaining);
    Map<String, dynamic>? additionalPropertiesValue;
    if (unmatched.isNotEmpty) {
      final additionalPropertiesMap = <String, dynamic>{};
      for (final entry in unmatched.entries) {
        final value = entry.value;
        additionalPropertiesMap[entry.key] = value;
      }
      additionalPropertiesValue = additionalPropertiesMap.isEmpty
          ? null
          : additionalPropertiesMap;
      unmatched = <String, dynamic>{};
    } else {
      additionalPropertiesValue = null;
    }
    return ToolExecutionCompleteDataToolTelemetry(
      additionalProperties: additionalPropertiesValue,
    );
  }
  final Map<String, dynamic>? additionalProperties;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (additionalProperties != null) {
      additionalProperties!.forEach((key, value) {
        map[key] = value;
      });
    }
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolExecutionCompleteData {
  const ToolExecutionCompleteData({
    required this.success,
    required this.toolCallId,
    this.error,
    this.isUserRequested,
    this.parentToolCallId,
    this.result,
    this.toolTelemetry,
  });

  factory ToolExecutionCompleteData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final error = json['error'] == null
        ? null
        : ToolExecutionCompleteDataError.fromJson(
            (json['error'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('error');
    final isUserRequested = json['isUserRequested'] as bool?;
    remaining.remove('isUserRequested');
    final parentToolCallId = json['parentToolCallId'] as String?;
    remaining.remove('parentToolCallId');
    final result = json['result'] == null
        ? null
        : ToolExecutionCompleteDataResult.fromJson(
            (json['result'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('result');
    final success = json['success'] as bool;
    remaining.remove('success');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final toolTelemetry = json['toolTelemetry'] == null
        ? null
        : ToolExecutionCompleteDataToolTelemetry.fromJson(
            (json['toolTelemetry'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('toolTelemetry');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionCompleteData(
      error: error,
      isUserRequested: isUserRequested,
      parentToolCallId: parentToolCallId,
      result: result,
      success: success,
      toolCallId: toolCallId,
      toolTelemetry: toolTelemetry,
    );
  }
  final ToolExecutionCompleteDataError? error;
  final bool? isUserRequested;
  final String? parentToolCallId;
  final ToolExecutionCompleteDataResult? result;
  final bool success;
  final String toolCallId;
  final ToolExecutionCompleteDataToolTelemetry? toolTelemetry;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (error != null) map['error'] = error!.toJson();
    if (isUserRequested != null) map['isUserRequested'] = isUserRequested;
    if (parentToolCallId != null) map['parentToolCallId'] = parentToolCallId;
    if (result != null) map['result'] = result!.toJson();
    map['success'] = success;
    map['toolCallId'] = toolCallId;
    if (toolTelemetry != null) map['toolTelemetry'] = toolTelemetry!.toJson();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class ToolExecutionComplete extends SessionEvent {
  const ToolExecutionComplete({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory ToolExecutionComplete.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = ToolExecutionCompleteData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return ToolExecutionComplete(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final ToolExecutionCompleteData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: tool.execution_complete
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/28/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'tool.execution_complete') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'tool.execution_complete' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class SkillInvokedData {
  const SkillInvokedData({
    required this.content,
    required this.name,
    required this.path,
  });

  factory SkillInvokedData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = json['content'] as String;
    remaining.remove('content');
    final name = json['name'] as String;
    remaining.remove('name');
    final path = json['path'] as String;
    remaining.remove('path');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SkillInvokedData(
      content: content,
      name: name,
      path: path,
    );
  }
  final String content;
  final String name;
  final String path;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content;
    map['name'] = name;
    map['path'] = path;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SkillInvoked extends SessionEvent {
  const SkillInvoked({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SkillInvoked.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SkillInvokedData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SkillInvoked(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SkillInvokedData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: skill.invoked
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/29/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'skill.invoked') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'skill.invoked' but found " + actualp5 + '.',
      );
    }
  }
}

class SubagentStartedData {
  const SubagentStartedData({
    required this.agentDescription,
    required this.agentDisplayName,
    required this.agentName,
    required this.toolCallId,
  });

  factory SubagentStartedData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final agentDescription = json['agentDescription'] as String;
    remaining.remove('agentDescription');
    final agentDisplayName = json['agentDisplayName'] as String;
    remaining.remove('agentDisplayName');
    final agentName = json['agentName'] as String;
    remaining.remove('agentName');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SubagentStartedData(
      agentDescription: agentDescription,
      agentDisplayName: agentDisplayName,
      agentName: agentName,
      toolCallId: toolCallId,
    );
  }
  final String agentDescription;
  final String agentDisplayName;
  final String agentName;
  final String toolCallId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['agentDescription'] = agentDescription;
    map['agentDisplayName'] = agentDisplayName;
    map['agentName'] = agentName;
    map['toolCallId'] = toolCallId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SubagentStarted extends SessionEvent {
  const SubagentStarted({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SubagentStarted.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SubagentStartedData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SubagentStarted(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SubagentStartedData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: subagent.started
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/30/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'subagent.started') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'subagent.started' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class SubagentCompletedData {
  const SubagentCompletedData({
    required this.agentName,
    required this.toolCallId,
  });

  factory SubagentCompletedData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final agentName = json['agentName'] as String;
    remaining.remove('agentName');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SubagentCompletedData(
      agentName: agentName,
      toolCallId: toolCallId,
    );
  }
  final String agentName;
  final String toolCallId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['agentName'] = agentName;
    map['toolCallId'] = toolCallId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SubagentCompleted extends SessionEvent {
  const SubagentCompleted({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SubagentCompleted.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SubagentCompletedData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SubagentCompleted(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SubagentCompletedData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: subagent.completed
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/31/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'subagent.completed') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'subagent.completed' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class SubagentFailedData {
  const SubagentFailedData({
    required this.agentName,
    required this.error,
    required this.toolCallId,
  });

  factory SubagentFailedData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final agentName = json['agentName'] as String;
    remaining.remove('agentName');
    final error = json['error'] as String;
    remaining.remove('error');
    final toolCallId = json['toolCallId'] as String;
    remaining.remove('toolCallId');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SubagentFailedData(
      agentName: agentName,
      error: error,
      toolCallId: toolCallId,
    );
  }
  final String agentName;
  final String error;
  final String toolCallId;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['agentName'] = agentName;
    map['error'] = error;
    map['toolCallId'] = toolCallId;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SubagentFailed extends SessionEvent {
  const SubagentFailed({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SubagentFailed.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SubagentFailedData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SubagentFailed(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SubagentFailedData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: subagent.failed
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/32/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'subagent.failed') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'subagent.failed' but found " + actualp5 + '.',
      );
    }
  }
}

class SubagentSelectedData {
  const SubagentSelectedData({
    required this.agentDisplayName,
    required this.agentName,
    this.tools,
  });

  factory SubagentSelectedData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final agentDisplayName = json['agentDisplayName'] as String;
    remaining.remove('agentDisplayName');
    final agentName = json['agentName'] as String;
    remaining.remove('agentName');
    final tools = json['tools'] == null
        ? null
        : (json['tools'] as List).map((e) => e as String).toList();
    remaining.remove('tools');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SubagentSelectedData(
      agentDisplayName: agentDisplayName,
      agentName: agentName,
      tools: tools,
    );
  }
  final String agentDisplayName;
  final String agentName;
  final List<String>? tools;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['agentDisplayName'] = agentDisplayName;
    map['agentName'] = agentName;
    if (tools != null) map['tools'] = tools;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'agentDisplayName');
    final value0 = agentDisplayName;
    context?.markProperty(pointer, 'agentDisplayName');
    final ptr1 = appendJsonPointer(pointer, 'agentName');
    final value1 = agentName;
    context?.markProperty(pointer, 'agentName');
    final ptr2 = appendJsonPointer(pointer, 'tools');
    final value2 = tools;
    if (value2 != null) {
      context?.markProperty(pointer, 'tools');
      final jsonp2 = value2;
      final constraintp2c0_0 = context == null ? null : ValidationContext();
      var constraintp2m0_0 = false;
      try {
        final context = constraintp2c0_0;
        final constraintp2v0_0 = (jsonp2 as List)
            .map((e) => e as String)
            .toList();
        constraintp2m0_0 = true;
      } catch (_) {}
      final constraintp2c0_1 = context == null ? null : ValidationContext();
      var constraintp2m0_1 = false;
      try {
        final context = constraintp2c0_1;
        final constraintp2v0_1 = jsonp2;
        constraintp2m0_1 = true;
      } catch (_) {}
      final constraintp2matches0 = <bool>[constraintp2m0_0, constraintp2m0_1];
      if (!constraintp2matches0.any((value) => value)) {
        throwValidationError(
          ptr2,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/33/properties/data/properties/tools/anyOf to validate.',
        );
      }
      if (context != null && constraintp2m0_0 && constraintp2c0_0 != null) {
        context.mergeFrom(constraintp2c0_0!);
      }
      if (context != null && constraintp2m0_1 && constraintp2c0_1 != null) {
        context.mergeFrom(constraintp2c0_1!);
      }
    }
  }
}

class SubagentSelected extends SessionEvent {
  const SubagentSelected({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SubagentSelected.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SubagentSelectedData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SubagentSelected(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SubagentSelectedData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: subagent.selected
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    value0.validate(pointer: ptr0, context: context);
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/33/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'subagent.selected') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'subagent.selected' but found " +
            actualp5 +
            '.',
      );
    }
  }
}

class HookStartData {
  const HookStartData({
    required this.hookInvocationId,
    required this.hookType,
    this.input,
  });

  factory HookStartData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final hookInvocationId = json['hookInvocationId'] as String;
    remaining.remove('hookInvocationId');
    final hookType = json['hookType'] as String;
    remaining.remove('hookType');
    final input = json['input'];
    remaining.remove('input');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return HookStartData(
      hookInvocationId: hookInvocationId,
      hookType: hookType,
      input: input,
    );
  }
  final String hookInvocationId;
  final String hookType;
  final dynamic input;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['hookInvocationId'] = hookInvocationId;
    map['hookType'] = hookType;
    if (input != null) map['input'] = input;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class HookStart extends SessionEvent {
  const HookStart({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory HookStart.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = HookStartData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return HookStart(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final HookStartData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: hook.start
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/34/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'hook.start') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'hook.start' but found " + actualp5 + '.',
      );
    }
  }
}

class HookEndDataError {
  const HookEndDataError({
    required this.message,
    this.stack,
  });

  factory HookEndDataError.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final message = json['message'] as String;
    remaining.remove('message');
    final stack = json['stack'] as String?;
    remaining.remove('stack');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return HookEndDataError(
      message: message,
      stack: stack,
    );
  }
  final String message;
  final String? stack;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['message'] = message;
    if (stack != null) map['stack'] = stack;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class HookEndData {
  const HookEndData({
    required this.hookInvocationId,
    required this.hookType,
    required this.success,
    this.error,
    this.output,
  });

  factory HookEndData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final error = json['error'] == null
        ? null
        : HookEndDataError.fromJson(
            (json['error'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('error');
    final hookInvocationId = json['hookInvocationId'] as String;
    remaining.remove('hookInvocationId');
    final hookType = json['hookType'] as String;
    remaining.remove('hookType');
    final output = json['output'];
    remaining.remove('output');
    final success = json['success'] as bool;
    remaining.remove('success');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return HookEndData(
      error: error,
      hookInvocationId: hookInvocationId,
      hookType: hookType,
      output: output,
      success: success,
    );
  }
  final HookEndDataError? error;
  final String hookInvocationId;
  final String hookType;
  final dynamic output;
  final bool success;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (error != null) map['error'] = error!.toJson();
    map['hookInvocationId'] = hookInvocationId;
    map['hookType'] = hookType;
    if (output != null) map['output'] = output;
    map['success'] = success;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class HookEnd extends SessionEvent {
  const HookEnd({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory HookEnd.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = HookEndData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return HookEnd(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final HookEndData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: hook.end
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/35/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'hook.end') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'hook.end' but found " + actualp5 + '.',
      );
    }
  }
}

class SystemMessageDataMetadataVariables {
  const SystemMessageDataMetadataVariables({
    this.additionalProperties,
  });

  factory SystemMessageDataMetadataVariables.fromJson(
    Map<String, dynamic> json,
  ) {
    final remaining = Map<String, dynamic>.from(json);
    var unmatched = Map<String, dynamic>.from(remaining);
    Map<String, dynamic>? additionalPropertiesValue;
    if (unmatched.isNotEmpty) {
      final additionalPropertiesMap = <String, dynamic>{};
      for (final entry in unmatched.entries) {
        final value = entry.value;
        additionalPropertiesMap[entry.key] = value;
      }
      additionalPropertiesValue = additionalPropertiesMap.isEmpty
          ? null
          : additionalPropertiesMap;
      unmatched = <String, dynamic>{};
    } else {
      additionalPropertiesValue = null;
    }
    return SystemMessageDataMetadataVariables(
      additionalProperties: additionalPropertiesValue,
    );
  }
  final Map<String, dynamic>? additionalProperties;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (additionalProperties != null) {
      additionalProperties!.forEach((key, value) {
        map[key] = value;
      });
    }
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SystemMessageDataMetadata {
  const SystemMessageDataMetadata({
    this.promptVersion,
    this.variables,
  });

  factory SystemMessageDataMetadata.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final promptVersion = json['promptVersion'] as String?;
    remaining.remove('promptVersion');
    final variables = json['variables'] == null
        ? null
        : SystemMessageDataMetadataVariables.fromJson(
            (json['variables'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('variables');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SystemMessageDataMetadata(
      promptVersion: promptVersion,
      variables: variables,
    );
  }
  final String? promptVersion;
  final SystemMessageDataMetadataVariables? variables;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    if (promptVersion != null) map['promptVersion'] = promptVersion;
    if (variables != null) map['variables'] = variables!.toJson();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SystemMessageData {
  const SystemMessageData({
    required this.content,
    required this.role,
    this.metadata,
    this.name,
  });

  factory SystemMessageData.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final content = json['content'] as String;
    remaining.remove('content');
    final metadata = json['metadata'] == null
        ? null
        : SystemMessageDataMetadata.fromJson(
            (json['metadata'] as Map).cast<String, dynamic>(),
          );
    remaining.remove('metadata');
    final name = json['name'] as String?;
    remaining.remove('name');
    final role = SystemMessageDataRoleJson.fromJson(json['role'] as String);
    remaining.remove('role');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SystemMessageData(
      content: content,
      metadata: metadata,
      name: name,
      role: role,
    );
  }
  final String content;
  final SystemMessageDataMetadata? metadata;
  final String? name;
  final SystemMessageDataRole role;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['content'] = content;
    if (metadata != null) map['metadata'] = metadata!.toJson();
    if (name != null) map['name'] = name;
    map['role'] = role.toJson();
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

class SystemMessage extends SessionEvent {
  const SystemMessage({
    required this.data,
    required this.id,
    required this.timestamp,
    required this.type,
    this.ephemeral,
    this.parentId,
  }) : super();

  factory SystemMessage.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final data = SystemMessageData.fromJson(
      (json['data'] as Map).cast<String, dynamic>(),
    );
    remaining.remove('data');
    final ephemeral = json['ephemeral'] as bool?;
    remaining.remove('ephemeral');
    final id = json['id'] as String;
    remaining.remove('id');
    final parentId = json['parentId'] as String?;
    remaining.remove('parentId');
    final timestamp = json['timestamp'] as String;
    remaining.remove('timestamp');
    final type = json['type'] as String;
    remaining.remove('type');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SystemMessage(
      data: data,
      ephemeral: ephemeral,
      id: id,
      parentId: parentId,
      timestamp: timestamp,
      type: type,
    );
  }
  final SystemMessageData data;
  final bool? ephemeral;

  /// Format: uuid (format hints disabled).
  ///
  /// Universally Unique Identifier as defined by RFC 4122.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-resource-identifiers.
  final String id;
  final String? parentId;

  /// Format: date-time (format hints disabled).
  ///
  /// Date and time as defined by RFC 3339 date-time.
  ///
  /// See https://json-schema.org/draft/2020-12/json-schema-validation.html#name-dates-times-and-duration.
  final String timestamp;

  /// Constraints: const: system.message
  final String type;

  @override
  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['data'] = data.toJson();
    if (ephemeral != null) map['ephemeral'] = ephemeral;
    map['id'] = id;
    if (parentId != null) map['parentId'] = parentId;
    map['timestamp'] = timestamp;
    map['type'] = type;
    return map;
  }

  @override
  void validate({String pointer = '', ValidationContext? context}) {
    final ptr0 = appendJsonPointer(pointer, 'data');
    final value0 = data;
    context?.markProperty(pointer, 'data');
    final ptr1 = appendJsonPointer(pointer, 'ephemeral');
    final value1 = ephemeral;
    if (value1 != null) {
      context?.markProperty(pointer, 'ephemeral');
    }
    final ptr2 = appendJsonPointer(pointer, 'id');
    final value2 = id;
    context?.markProperty(pointer, 'id');
    final ptr3 = appendJsonPointer(pointer, 'parentId');
    final value3 = parentId;
    if (value3 != null) {
      context?.markProperty(pointer, 'parentId');
      final jsonp3 = value3;
      final constraintp3c0_0 = context == null ? null : ValidationContext();
      var constraintp3m0_0 = false;
      try {
        final context = constraintp3c0_0;
        final constraintp3v0_0 = jsonp3 as String;
        constraintp3m0_0 = true;
      } catch (_) {}
      final constraintp3c0_1 = context == null ? null : ValidationContext();
      var constraintp3m0_1 = false;
      try {
        final context = constraintp3c0_1;
        final constraintp3v0_1 = jsonp3;
        constraintp3m0_1 = true;
      } catch (_) {}
      final constraintp3matches0 = <bool>[constraintp3m0_0, constraintp3m0_1];
      if (!constraintp3matches0.any((value) => value)) {
        throwValidationError(
          ptr3,
          'anyOf',
          'Expected at least one subschema in #/definitions/SessionEvent/anyOf/36/properties/parentId/anyOf to validate.',
        );
      }
      if (context != null && constraintp3m0_0 && constraintp3c0_0 != null) {
        context.mergeFrom(constraintp3c0_0!);
      }
      if (context != null && constraintp3m0_1 && constraintp3c0_1 != null) {
        context.mergeFrom(constraintp3c0_1!);
      }
    }
    final ptr4 = appendJsonPointer(pointer, 'timestamp');
    final value4 = timestamp;
    context?.markProperty(pointer, 'timestamp');
    final ptr5 = appendJsonPointer(pointer, 'type');
    final value5 = type;
    context?.markProperty(pointer, 'type');
    final actualp5 = value5;
    if (actualp5 != 'system.message') {
      throwValidationError(
        ptr5,
        'const',
        "Expected value equal to 'system.message' but found " + actualp5 + '.',
      );
    }
  }
}

class SelectionSelectionStart {
  const SelectionSelectionStart({
    required this.character,
    required this.line,
  });

  factory SelectionSelectionStart.fromJson(Map<String, dynamic> json) {
    final remaining = Map<String, dynamic>.from(json);
    final character = json['character'] as double;
    remaining.remove('character');
    final line = json['line'] as double;
    remaining.remove('line');
    final unmatched = Map<String, dynamic>.from(remaining);
    if (unmatched.isNotEmpty) {
      final unexpected = unmatched.keys.join(', ');
      throw ArgumentError('Unexpected additional properties: $unexpected');
    }
    return SelectionSelectionStart(
      character: character,
      line: line,
    );
  }
  final double character;
  final double line;

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['character'] = character;
    map['line'] = line;
    return map;
  }

  void validate({String pointer = '', ValidationContext? context}) {}
}

enum ImageUrlImageUrlDetail { auto, low, high }

extension ImageUrlImageUrlDetailJson on ImageUrlImageUrlDetail {
  String toJson() => const {
    ImageUrlImageUrlDetail.auto: 'auto',
    ImageUrlImageUrlDetail.low: 'low',
    ImageUrlImageUrlDetail.high: 'high',
  }[this]!;

  static ImageUrlImageUrlDetail fromJson(String value) => const {
    'auto': ImageUrlImageUrlDetail.auto,
    'low': ImageUrlImageUrlDetail.low,
    'high': ImageUrlImageUrlDetail.high,
  }[value]!;
}

enum InputAudioInputAudioFormat { wav, mp3 }

extension InputAudioInputAudioFormatJson on InputAudioInputAudioFormat {
  String toJson() => const {
    InputAudioInputAudioFormat.wav: 'wav',
    InputAudioInputAudioFormat.mp3: 'mp3',
  }[this]!;

  static InputAudioInputAudioFormat fromJson(String value) => const {
    'wav': InputAudioInputAudioFormat.wav,
    'mp3': InputAudioInputAudioFormat.mp3,
  }[value]!;
}

enum SessionImportLegacyDataLegacySessionSelectedModel {
  claudeSonnet45,
  claudeHaiku45,
  claudeOpus45,
  claudeSonnet4,
  gemini3ProPreview,
  gpt52Codex,
  gpt52,
  gpt51CodexMax,
  gpt51Codex,
  gpt51,
  gpt5,
  gpt51CodexMini,
  gpt5Mini,
  gpt41,
}

extension SessionImportLegacyDataLegacySessionSelectedModelJson
    on SessionImportLegacyDataLegacySessionSelectedModel {
  String toJson() => const {
    SessionImportLegacyDataLegacySessionSelectedModel.claudeSonnet45:
        'claude-sonnet-4.5',
    SessionImportLegacyDataLegacySessionSelectedModel.claudeHaiku45:
        'claude-haiku-4.5',
    SessionImportLegacyDataLegacySessionSelectedModel.claudeOpus45:
        'claude-opus-4.5',
    SessionImportLegacyDataLegacySessionSelectedModel.claudeSonnet4:
        'claude-sonnet-4',
    SessionImportLegacyDataLegacySessionSelectedModel.gemini3ProPreview:
        'gemini-3-pro-preview',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt52Codex:
        'gpt-5.2-codex',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt52: 'gpt-5.2',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt51CodexMax:
        'gpt-5.1-codex-max',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt51Codex:
        'gpt-5.1-codex',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt51: 'gpt-5.1',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt5: 'gpt-5',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt51CodexMini:
        'gpt-5.1-codex-mini',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt5Mini: 'gpt-5-mini',
    SessionImportLegacyDataLegacySessionSelectedModel.gpt41: 'gpt-4.1',
  }[this]!;

  static SessionImportLegacyDataLegacySessionSelectedModel fromJson(
    String value,
  ) => const {
    'claude-sonnet-4.5':
        SessionImportLegacyDataLegacySessionSelectedModel.claudeSonnet45,
    'claude-haiku-4.5':
        SessionImportLegacyDataLegacySessionSelectedModel.claudeHaiku45,
    'claude-opus-4.5':
        SessionImportLegacyDataLegacySessionSelectedModel.claudeOpus45,
    'claude-sonnet-4':
        SessionImportLegacyDataLegacySessionSelectedModel.claudeSonnet4,
    'gemini-3-pro-preview':
        SessionImportLegacyDataLegacySessionSelectedModel.gemini3ProPreview,
    'gpt-5.2-codex':
        SessionImportLegacyDataLegacySessionSelectedModel.gpt52Codex,
    'gpt-5.2': SessionImportLegacyDataLegacySessionSelectedModel.gpt52,
    'gpt-5.1-codex-max':
        SessionImportLegacyDataLegacySessionSelectedModel.gpt51CodexMax,
    'gpt-5.1-codex':
        SessionImportLegacyDataLegacySessionSelectedModel.gpt51Codex,
    'gpt-5.1': SessionImportLegacyDataLegacySessionSelectedModel.gpt51,
    'gpt-5': SessionImportLegacyDataLegacySessionSelectedModel.gpt5,
    'gpt-5.1-codex-mini':
        SessionImportLegacyDataLegacySessionSelectedModel.gpt51CodexMini,
    'gpt-5-mini': SessionImportLegacyDataLegacySessionSelectedModel.gpt5Mini,
    'gpt-4.1': SessionImportLegacyDataLegacySessionSelectedModel.gpt41,
  }[value]!;
}

enum SessionHandoffDataSourceType { remote, local }

extension SessionHandoffDataSourceTypeJson on SessionHandoffDataSourceType {
  String toJson() => const {
    SessionHandoffDataSourceType.remote: 'remote',
    SessionHandoffDataSourceType.local: 'local',
  }[this]!;

  static SessionHandoffDataSourceType fromJson(String value) => const {
    'remote': SessionHandoffDataSourceType.remote,
    'local': SessionHandoffDataSourceType.local,
  }[value]!;
}

enum AssistantMessageDataToolRequestType { function, custom }

extension AssistantMessageDataToolRequestTypeJson
    on AssistantMessageDataToolRequestType {
  String toJson() => const {
    AssistantMessageDataToolRequestType.function: 'function',
    AssistantMessageDataToolRequestType.custom: 'custom',
  }[this]!;

  static AssistantMessageDataToolRequestType fromJson(String value) => const {
    'function': AssistantMessageDataToolRequestType.function,
    'custom': AssistantMessageDataToolRequestType.custom,
  }[value]!;
}

enum SystemMessageDataRole { system, developer }

extension SystemMessageDataRoleJson on SystemMessageDataRole {
  String toJson() => const {
    SystemMessageDataRole.system: 'system',
    SystemMessageDataRole.developer: 'developer',
  }[this]!;

  static SystemMessageDataRole fromJson(String value) => const {
    'system': SystemMessageDataRole.system,
    'developer': SystemMessageDataRole.developer,
  }[value]!;
}

String appendJsonPointer(String pointer, String token) {
  final escaped = token.replaceAll('~', '~0').replaceAll('/', '~1');
  if (pointer.isEmpty) return '/$escaped';
  return '$pointer/$escaped';
}

String uniqueItemKey(Object? value) => jsonEncode(value);

Never throwValidationError(String pointer, String keyword, String message) =>
    throw ValidationError(pointer: pointer, keyword: keyword, message: message);

class ValidationAnnotation {
  const ValidationAnnotation({
    required this.keyword,
    required this.value,
    this.schemaPointer,
  });

  final String keyword;
  final Object? value;
  final String? schemaPointer;
}

class ValidationContext {
  ValidationContext();

  final Map<String, List<ValidationAnnotation>> annotations =
      <String, List<ValidationAnnotation>>{};
  final Map<String, Set<String>> evaluatedProperties = <String, Set<String>>{};
  final Map<String, Set<int>> evaluatedItems = <String, Set<int>>{};

  void annotate(
    String pointer,
    String keyword,
    Object? value, {
    String? schemaPointer,
  }) {
    final list = annotations.putIfAbsent(
      pointer,
      () => <ValidationAnnotation>[],
    );
    list.add(
      ValidationAnnotation(
        keyword: keyword,
        value: value,
        schemaPointer: schemaPointer,
      ),
    );
  }

  void markProperty(String pointer, String property) {
    evaluatedProperties.putIfAbsent(pointer, () => <String>{}).add(property);
  }

  void markItem(String pointer, int index) {
    evaluatedItems.putIfAbsent(pointer, () => <int>{}).add(index);
  }

  void mergeFrom(ValidationContext other) {
    for (final entry in other.annotations.entries) {
      final list = annotations.putIfAbsent(
        entry.key,
        () => <ValidationAnnotation>[],
      );
      list.addAll(entry.value);
    }
    for (final entry in other.evaluatedProperties.entries) {
      evaluatedProperties
          .putIfAbsent(entry.key, () => <String>{})
          .addAll(entry.value);
    }
    for (final entry in other.evaluatedItems.entries) {
      evaluatedItems.putIfAbsent(entry.key, () => <int>{}).addAll(entry.value);
    }
  }
}

class ValidationError implements Exception {
  ValidationError({
    required this.pointer,
    required this.keyword,
    required this.message,
  });

  final String pointer;
  final String keyword;
  final String message;

  @override
  String toString() => 'ValidationError($keyword @ $pointer: $message)';
}

bool isValidFormat(String format, String value) {
  switch (format) {
    case 'date-time':
      return _dateTimePattern.hasMatch(value);
    case 'date':
      return _datePattern.hasMatch(value);
    case 'time':
      return _timePattern.hasMatch(value);
    case 'duration':
      return _durationPattern.hasMatch(value);
    case 'email':
    case 'idn-email':
      return _emailPattern.hasMatch(value);
    case 'hostname':
    case 'idn-hostname':
      return _isHostname(value);
    case 'ipv4':
      return _ipv4Pattern.hasMatch(value);
    case 'ipv6':
      return _isIpv6(value);
    case 'uri':
      return _isUri(value, requireScheme: true);
    case 'uri-reference':
      return _isUri(value, requireScheme: false);
    case 'iri':
      return _isIri(value, requireScheme: true);
    case 'iri-reference':
      return _isIri(value, requireScheme: false);
    case 'uri-template':
      return _isUriTemplate(value);
    case 'json-pointer':
      return _isJsonPointer(value);
    case 'relative-json-pointer':
      return _isRelativeJsonPointer(value);
    case 'regex':
      return _isValidRegex(value);
    default:
      return true;
  }
}

final RegExp _dateTimePattern = RegExp(
  r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})$',
);
final RegExp _datePattern = RegExp(r'^\d{4}-\d{2}-\d{2}$');
final RegExp _timePattern = RegExp(
  r'^\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?$',
);
final RegExp _durationPattern = RegExp(
  r'^P(?!$)(?:\d+Y)?(?:\d+M)?(?:\d+W)?(?:\d+D)?(?:T(?:\d+H)?(?:\d+M)?(?:\d+(?:\.\d+)?S)?)?$',
);
final RegExp _emailPattern = RegExp(r'^[^\s@]+@[^\s@]+\.[^\s@]+$');
final RegExp _ipv4Pattern = RegExp(
  r'^(25[0-5]|2[0-4]\d|1?\d?\d)(\.(25[0-5]|2[0-4]\d|1?\d?\d)){3}$',
);

bool _isIpv6(String value) {
  if (!RegExp(r'^[0-9A-Fa-f:]+$').hasMatch(value)) {
    return false;
  }
  final parts = value.split(':');
  if (parts.length < 3 || parts.length > 8) {
    return false;
  }
  for (final part in parts) {
    if (part.isEmpty) {
      continue;
    }
    if (part.length > 4) {
      return false;
    }
  }
  return true;
}

bool _isUri(String value, {required bool requireScheme}) {
  final uri = Uri.tryParse(value);
  if (uri == null) {
    return false;
  }
  if (requireScheme && !uri.hasScheme) {
    return false;
  }
  return true;
}

bool _isIri(String value, {required bool requireScheme}) {
  return _isUri(value, requireScheme: requireScheme);
}

bool _isUriTemplate(String value) {
  if (value.contains(RegExp(r'\s'))) {
    return false;
  }
  var depth = 0;
  for (final rune in value.runes) {
    if (rune == 123) {
      depth++;
    } else if (rune == 125) {
      depth--;
      if (depth < 0) {
        return false;
      }
    }
  }
  return depth == 0;
}

bool _isHostname(String value) {
  if (value.isEmpty || value.length > 253) {
    return false;
  }
  final labels = value.split('.');
  final labelPattern = RegExp(
    r'^[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?$',
  );
  for (final label in labels) {
    if (label.isEmpty || label.length > 63) {
      return false;
    }
    if (!labelPattern.hasMatch(label)) {
      return false;
    }
  }
  return true;
}

bool _isJsonPointer(String value) {
  if (value.isEmpty) {
    return true;
  }
  if (!value.startsWith('/')) {
    return false;
  }
  for (var i = 0; i < value.length; i++) {
    if (value.codeUnitAt(i) == 126) {
      if (i + 1 >= value.length) {
        return false;
      }
      final next = value.codeUnitAt(i + 1);
      if (next != 48 && next != 49) {
        return false;
      }
      i++;
    }
  }
  return true;
}

bool _isRelativeJsonPointer(String value) {
  final match = RegExp(r'^(0|[1-9]\d*)(.*)$').firstMatch(value);
  if (match == null) {
    return false;
  }
  final suffix = match.group(2)!;
  if (suffix.isEmpty || suffix == '#') {
    return true;
  }
  if (suffix.startsWith('/')) {
    return _isJsonPointer(suffix);
  }
  return false;
}

bool _isValidRegex(String value) {
  try {
    RegExp(value);
    return true;
  } catch (_) {
    return false;
  }
}

/// Parses [str] as JSON and deserializes it into a [SessionEvent].
SessionEvent sessionEventFromJson(String str) =>
    SessionEvent.fromJson(json.decode(str) as Map<String, dynamic>);

/// Serializes [data] into a JSON string.
String sessionEventToJson(SessionEvent data) => json.encode(data.toJson());
